<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>FigmaLint</title>
  <style>
    /* Carbon-Inspired Design System for FigmaLint */
    :root {
      /* Carbon-inspired color tokens */
      --background: #f4f4f4;
      --surface: #ffffff;
      --surface-alt: #e0e0e0;
      --surface-hover: #e8e8e8;
      --border: #e0e0e0;
      --border-strong: #8d8d8d;
      --text-primary: #161616;
      --text-secondary: #525252;
      --text-tertiary: #a8a8a8;
      --text-on-color: #ffffff;

      /* Interactive */
      --interactive: #0f62fe;
      --interactive-hover: #0353e9;
      --interactive-active: #002d9c;
      --interactive-light: #edf5ff;

      /* Semantic status */
      --success: #198038;
      --success-bg: #defbe6;
      --success-text: #198038;
      --warning: #f1c21b;
      --warning-bg: #fdf6dd;
      --warning-text: #8e6a00;
      --error: #da1e28;
      --error-bg: #fff1f1;
      --error-text: #da1e28;
      --info: #0043ce;
      --info-bg: #edf5ff;
      --info-text: #0043ce;

      /* Carbon spacing scale (2px base) */
      --spacing-01: 2px;
      --spacing-02: 4px;
      --spacing-03: 8px;
      --spacing-04: 12px;
      --spacing-05: 16px;
      --spacing-06: 24px;
      --spacing-07: 32px;
      --spacing-08: 40px;
      --spacing-09: 48px;

      /* Carbon border radius */
      --radius-sm: 2px;
      --radius-md: 4px;
      --radius-lg: 8px;

      /* Typography */
      --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      --font-size-xs: 0.6875rem;   /* 11px */
      --font-size-sm: 0.75rem;     /* 12px */
      --font-size-md: 0.875rem;    /* 14px */
      --font-size-lg: 1rem;        /* 16px */
      --font-weight-regular: 400;
      --font-weight-medium: 500;
      --font-weight-semibold: 600;
      --line-height-tight: 1.25;
      --line-height-normal: 1.5;

      /* Shadows (subtle, Carbon-like) */
      --shadow-sm: 0 1px 2px rgba(0,0,0,0.05);
      --shadow-md: 0 2px 6px rgba(0,0,0,0.08);
      --shadow-lg: 0 4px 12px rgba(0,0,0,0.12);

      /* Z-index scale */
      --z-dropdown: 100;
      --z-tooltip: 200;
      --z-modal: 300;

      /* Transitions */
      --transition-fast: 150ms ease;
      --transition-base: 250ms ease;
      --transition-slow: 350ms ease;

      /* Legacy aliases (keep JS references working) */
      --primary: var(--interactive);
      --primary-hover: var(--interactive-hover);
      --primary-light: var(--interactive-light);
      --secondary: var(--text-secondary);
      --space-xs: var(--spacing-02);
      --space-sm: var(--spacing-03);
      --space-md: var(--spacing-05);
      --space-lg: var(--spacing-06);
      --space-xl: var(--spacing-07);
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-family);
      margin: 0;
      padding: 0;
      background-color: var(--background);
      color: var(--text-primary);
      font-size: var(--font-size-sm);
      line-height: var(--line-height-normal);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      background: var(--background);
    }

    /* Header Section */
    .header {
      padding: var(--spacing-05) var(--spacing-05) var(--spacing-03);
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      min-height: 60px;
      position: relative;
      z-index: 10;
      margin-bottom: var(--spacing-03);
    }

    /* Ensure header bottom padding is maintained */
    .header::after {
      content: '';
      display: block;
      height: 1px;
      clear: both;
    }

    .plugin-title {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      margin-bottom: var(--space-xs);
    }

    .plugin-icon {
      width: 20px;
      height: 20px;
      background: var(--interactive);
      border-radius: var(--radius-sm);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-on-color);
      font-weight: var(--font-weight-semibold);
      font-size: var(--font-size-xs);
    }

    .plugin-name {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      margin: 0;
    }

    .plugin-description {
      font-size: 12px;
      color: var(--text-secondary);
      margin: 0;
    }

    /* Tabs Navigation */
    .tabs-navigation {
      display: flex;
      padding: 0 var(--spacing-05) 0;
      border-bottom: 1px solid var(--border);
      background: var(--surface);
      position: sticky;
      top: 0;
      z-index: var(--z-dropdown);
    }


    /* Main Content */
    .content {
      flex: 1;
      padding: var(--space-md);
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    /* Card Component */
    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      padding: var(--spacing-05);
      transition: border-color var(--transition-fast);
    }

    .card:hover {
      border-color: var(--border-strong);
    }

    .card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--space-sm);
      flex-wrap: wrap;
      gap: var(--space-sm);
    }

    .card-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-primary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin: 0;
    }

    .card-subtitle {
      font-size: 11px;
      color: var(--text-tertiary);
      margin: 2px 0 0 0;
      line-height: 1.3;
    }

    /* Collapsible Sections */
    .collapsible {
      margin-bottom: var(--spacing-05);
    }

    .collapsible-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--spacing-03) var(--spacing-05);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: background var(--transition-fast);
      user-select: none;
    }

    .collapsible-header:hover {
      background: var(--surface-hover);
    }

    .collapsible-header.active {
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
    }

    .collapsible-title {
      font-size: var(--font-size-md);
      font-weight: var(--font-weight-semibold);
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .collapsible-title > .tooltip {
      /* tooltip positioning handled by general tooltip rules */
    }

    .collapsible-icon {
      transition: transform var(--transition-fast);
      font-size: var(--font-size-sm);
      color: var(--text-secondary);
      width: 16px;
      text-align: center;
    }

    .collapsible-header.active .collapsible-icon {
      transform: rotate(90deg);
    }

    .collapsible-content {
      display: none;
      padding: var(--spacing-05);
      background: var(--surface);
      border: 1px solid var(--border);
      border-top: none;
      border-bottom-left-radius: var(--radius-md);
      border-bottom-right-radius: var(--radius-md);
    }

    .collapsible-content.active {
      display: block;
    }

    /* Form Elements */
    .form-group {
      display: flex;
      flex-direction: column;
      gap: 2px;
      margin-bottom: var(--space-md);
    }

    .form-group:last-child {
      margin-bottom: 0;
    }

    label {
      font-size: 11px;
      font-weight: 500;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .input-wrapper {
      position: relative;
      display: flex;
      align-items: center;
    }

    input, textarea, select {
      width: 100%;
      padding: var(--spacing-03) var(--spacing-04);
      border: 1px solid var(--border-strong);
      border-radius: var(--radius-sm);
      font-size: var(--font-size-sm);
      font-family: inherit;
      background: var(--surface);
      color: var(--text-primary);
      transition: border-color var(--transition-fast);
      min-height: 32px;
    }

    textarea {
      min-height: 80px !important;
      resize: vertical;
    }

    input:hover, textarea:hover, select:hover {
      border-color: var(--text-tertiary);
    }

    input:focus, textarea:focus, select:focus {
      outline: none;
      border-color: var(--interactive);
      box-shadow: 0 0 0 2px var(--interactive);
    }

    input::placeholder, textarea::placeholder {
      color: var(--text-tertiary);
    }

    .input-icon {
      position: absolute;
      right: var(--space-sm);
      color: var(--text-tertiary);
      pointer-events: none;
    }

    /* Button Styles (Carbon spec) */
    .button {
      padding: var(--spacing-02) var(--spacing-04);
      border: none;
      border-radius: var(--radius-sm);
      font-size: var(--font-size-xs);
      font-weight: var(--font-weight-medium);
      font-family: inherit;
      cursor: pointer;
      transition: background var(--transition-fast), border-color var(--transition-fast);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--spacing-02);
      min-height: 32px;
    }

    .button-primary {
      background: var(--interactive);
      color: var(--text-on-color);
    }

    .button-primary:hover:not(:disabled) {
      background: var(--interactive-hover);
    }

    .button-primary:active:not(:disabled) {
      background: var(--interactive-active);
    }

    .button-secondary {
      background: transparent;
      color: var(--text-primary);
      border: 1px solid var(--border-strong);
    }

    .button-secondary:hover:not(:disabled) {
      background: var(--surface-hover);
      border-color: var(--text-primary);
    }

    .button-ghost {
      background: transparent;
      color: var(--interactive);
      border: 1px solid transparent;
    }

    .button-ghost:hover:not(:disabled) {
      background: var(--interactive-light);
    }

    .button-danger {
      background: var(--error);
      color: var(--text-on-color);
    }

    .button-danger:hover:not(:disabled) {
      background: #ba1b23;
    }

    .button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .button-group {
      display: flex;
      gap: var(--spacing-03);
      align-items: center;
      margin-bottom: var(--spacing-05);
    }

    .button-icon {
      width: 16px;
      height: 16px;
    }

    /* Status Messages (Carbon inline notification) */
    .status-banner {
      padding: var(--spacing-04);
      border-radius: var(--radius-sm);
      font-size: var(--font-size-sm);
      display: flex;
      align-items: center;
      gap: var(--spacing-03);
      transition: background var(--transition-fast);
      border-left: 4px solid transparent;
    }

    .status-icon {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
    }

    .status-info {
      background: var(--info-bg);
      color: var(--info-text);
      border-left-color: var(--info);
    }

    .status-success {
      background: var(--success-bg);
      color: var(--success-text);
      border-left-color: var(--success);
    }

    .status-error {
      background: var(--error-bg);
      color: var(--error-text);
      border-left-color: var(--error);
    }

    .status-warning {
      background: var(--warning-bg);
      color: var(--warning-text);
      border-left-color: var(--warning);
    }

    /* Audit View Styles */
    .audit-section:not(:last-child) {
      margin-bottom: var(--spacing-06);
    }

    .audit-item {
      display: flex;
      padding: var(--spacing-03);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      margin-bottom: var(--spacing-03);
      gap: var(--spacing-03);
    }

    .audit-item.pass-item {
      background: var(--success-bg);
    }

    .audit-item.fail-item {
      background: var(--error-bg);
    }

    .audit-item.warning-item {
      background: var(--warning-bg);
    }

    .audit-status {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
    }

    .audit-status.pass {
      color: var(--success);
    }

    .audit-status.fail {
      color: var(--error);
    }

    .audit-status.warning {
      color: var(--warning-text);
    }

    .audit-status.info {
      color: var(--info);
    }

    .audit-content {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .audit-label {
      flex: 1;
      font-size: var(--font-size-sm);
      color: var(--text-primary);
    }

    .audit-action {
      font-size: var(--font-size-xs);
      color: var(--interactive);
      cursor: pointer;
      text-decoration: none;
    }

    .audit-action:hover {
      text-decoration: underline;
    }

    .audit-action-button {
      font-size: var(--font-size-xs);
      color: var(--interactive);
      background: transparent;
      border: 1px solid var(--interactive);
      border-radius: var(--radius-sm);
      padding: var(--spacing-02) var(--spacing-04);
      cursor: pointer;
      transition: background var(--transition-fast);
      min-height: 24px;
    }

    .audit-action-button:hover {
      background: var(--interactive-light);
    }

    /* Property Cheat Sheet */
    .property-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
      table-layout: fixed;
    }

    .property-table th {
      text-align: left;
      padding: var(--space-sm);
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      font-size: 11px;
      letter-spacing: 0.5px;
    }

    .property-table th:first-child {
      width: 25%;
    }

    .property-table th:last-child {
      width: 22%;
    }

    .property-table td {
      padding: var(--space-sm);
      border-bottom: 1px solid var(--border);
      color: var(--text-primary);
      vertical-align: top;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .property-values-cell {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .property-table tr:hover {
      background: var(--surface);
    }

    .property-value {
      display: inline-block;
      padding: 2px 6px;
      background: var(--interactive-light);
      color: var(--interactive);
      border-radius: var(--radius-sm);
      font-size: var(--font-size-xs);
      white-space: nowrap;
      vertical-align: middle;
    }

    .property-default-value {
      font-size: var(--font-size-xs);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      display: block;
    }

    /* Token Analysis */
    .token-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: var(--space-sm);
    }

    .token-item {
      padding: var(--space-sm);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      font-size: 11px;
      text-align: center;
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .token-item:hover {
      background: var(--surface-hover);
      border-color: var(--primary);
    }

    .token-preview {
      width: 100%;
      height: 24px;
      border-radius: var(--radius-sm);
      margin-bottom: var(--space-xs);
    }

    /* Enhanced Token Display */
    .token-item-enhanced {
      display: flex;
      align-items: center;
      padding: var(--space-sm);
      background: var(--surface);
      border-radius: var(--radius-sm);
      margin-bottom: var(--space-xs);
      gap: var(--space-sm);
      border: 1px solid var(--border);
      transition: all var(--transition-base);
    }

    .token-item-enhanced:hover {
      border-color: var(--interactive);
    }

    .token-item-enhanced.suggestion {
      background: var(--interactive-light);
      border-left: 3px solid var(--interactive);
    }

    /* Compact Token Display */
    .token-item-compact {
      display: flex;
      padding: var(--spacing-03);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      margin-bottom: var(--spacing-02);
      gap: var(--spacing-03);
      transition: border-color var(--transition-fast);
    }

    .token-item-compact:hover {
      border-color: var(--interactive);
    }

    .token-item-compact.warning {
      background: var(--warning-bg);
      border-left: 3px solid var(--warning);
    }

    .token-item-compact.suggestion {
      background: var(--interactive-light);
      border-left: 3px solid var(--interactive);
    }

    .token-swatch-spacing {
      height: 12px;
      border-radius: 2px;
      background: var(--primary);
      flex-shrink: 0;
    }


    .token-preview-border {
      width: 20px;
      height: 20px;
      background: var(--surface);
      border: 1px solid var(--border);
      flex-shrink: 0;
    }

    .token-preview-text {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 2px;
      background: var(--surface);
      flex-shrink: 0;
      font-size: 12px;
      font-weight: 500;
    }

    .token-info {
      flex: 1;
    }

    .token-name {
      font-size: var(--font-size-xs);
      font-weight: var(--font-weight-semibold);
      color: var(--text-primary);
      margin-bottom: 2px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .token-usage {
      font-size: 10px;
      color: var(--text-secondary);
      line-height: var(--line-height-tight);
      word-wrap: break-word;
    }

    .token-value {
      font-size: 10px;
      color: var(--text-tertiary);
      font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
    }

    .token-preview-spacing {
      max-width: 40px;
      min-height: 8px;
      border-radius: var(--radius-sm);
    }

    .token-preview-text {
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text-primary);
    }

    .token-swatch {
      width: 20px;
      height: 20px;
      border-radius: var(--radius-sm);
      border: 1px solid rgba(0,0,0,0.1);
      flex-shrink: 0;
      cursor: pointer;
      transition: transform var(--transition-fast);
    }

    .token-swatch:hover {
      transform: scale(1.1);
    }

    .token-swatch-spacing {
      height: 12px;
      min-width: 8px;
      max-width: 40px;
      border-radius: var(--radius-sm);
      border: 1px solid rgba(0,0,0,0.1);
      flex-shrink: 0;
    }

    .token-details {
      flex: 1;
      min-width: 0;
    }

    /* (.token-name and .token-usage consolidated above) */

    /* Playground Grid */
    .playground-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: var(--space-md);
      padding: var(--space-md);
      background: var(--surface);
      border-radius: var(--radius-md);
    }

    .playground-item {
      background: var(--background);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      padding: var(--space-md);
      text-align: center;
      min-height: 120px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: var(--space-sm);
    }

    .playground-label {
      font-size: 11px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Documentation Frame */
    .doc-preview {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      padding: var(--space-lg);
      min-height: 200px;
    }

    .doc-section {
      margin-bottom: var(--space-lg);
    }

    .doc-section:last-child {
      margin-bottom: 0;
    }

    .doc-heading {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: var(--space-sm);
    }

    .doc-content {
      font-size: 12px;
      color: var(--text-secondary);
      line-height: 1.8;
    }

    /* Export Options */
    .export-options {
      display: flex;
      gap: var(--space-md);
      align-items: stretch;
      flex-wrap: wrap;
      justify-content: flex-start;
      min-width: 0;
    }

    .export-options .button {
      font-size: 12px;
      padding: 6px 16px;
      min-height: 30px;
      flex: 0 0 auto;
    }

    .export-options select {
      font-size: 12px;
      padding: 6px 12px;
      min-height: 30px;
    }

    .export-select {
      min-width: 120px;
      font-size: 12px;
    }

    /* Batch Mode */
    .batch-toggle {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      padding: var(--space-sm);
      background: var(--warning);
      color: white;
      border-radius: var(--radius-md);
      font-size: 12px;
      margin-bottom: var(--space-md);
    }

    .batch-list {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      padding: var(--space-sm);
    }

    .batch-item {
      display: flex;
      align-items: center;
      padding: var(--space-xs) var(--space-sm);
      font-size: 12px;
      border-radius: var(--radius-sm);
      cursor: pointer;
    }

    .batch-item:hover {
      background: var(--surface);
    }

    .batch-item.selected {
      background: var(--primary-light);
      color: var(--primary);
    }

    /* Loading States */
    .skeleton {
      background: linear-gradient(90deg, var(--surface) 25%, var(--surface-hover) 50%, var(--surface) 75%);
      background-size: 200% 100%;
      animation: skeleton-loading 1.5s infinite;
      border-radius: var(--radius-sm);
      height: 16px;
      margin: var(--space-xs) 0;
    }

    @keyframes skeleton-loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    /* Spinner */
    .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid var(--surface);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Footer Links */
    .footer-links {
      padding: var(--spacing-03);
      text-align: center;
      border-top: 1px solid var(--border);
      background: var(--surface);
      margin-top: auto;
    }

    .footer-link {
      font-size: var(--font-size-xs);
      color: var(--text-secondary);
      text-decoration: none;
      transition: color var(--transition-fast);
      padding: var(--spacing-02) var(--spacing-03);
      border-radius: var(--radius-sm);
      display: inline-block;
      background: transparent;
      border: 1px solid transparent;
    }

    .footer-link:hover {
      color: var(--interactive);
      text-decoration: underline;
    }

    /* Utility Classes */
    .hidden {
      display: none !important;
    }

    /* Tooltip Styles (JS-positioned) */
    .tooltip {
      position: relative;
      display: inline-flex;
      cursor: help;
      margin-left: 0;
    }

    .tooltip .tooltiptext {
      display: none;
    }

    .tooltip-popup {
      position: fixed;
      z-index: var(--z-tooltip);
      background: var(--surface);
      color: var(--text-primary);
      text-align: left;
      border-radius: var(--radius-md);
      padding: var(--spacing-03) var(--spacing-04);
      font-size: var(--font-size-xs);
      line-height: 1.4;
      box-shadow: var(--shadow-md);
      border: 1px solid var(--border);
      max-width: 280px;
      pointer-events: none;
    }

    .tooltip-popup::before {
      content: "";
      position: absolute;
      left: 16px;
      border-width: 5px;
      border-style: solid;
    }

    .tooltip-popup.tooltip-above::before {
      top: 100%;
      border-color: var(--border) transparent transparent transparent;
    }

    .tooltip-popup.tooltip-below::before {
      bottom: 100%;
      border-color: transparent transparent var(--border) transparent;
    }

    .section-header {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: var(--spacing-03);
    }

    .section-title {
      font-size: var(--font-size-sm);
      font-weight: var(--font-weight-semibold);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
      margin: 0;
    }

    .info-icon {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--text-tertiary);
      color: var(--surface);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: var(--font-weight-semibold);
      margin-left: var(--spacing-02);
    }

    .mt-sm { margin-top: var(--space-sm); }
    .mt-md { margin-top: var(--space-md); }
    .mb-sm { margin-bottom: var(--space-sm); }
    .mb-md { margin-bottom: var(--space-md); }

    .token-section-divider {
      border: none;
      border-top: 1px solid var(--border);
      margin: 12px 0;
    }

    /* Responsive Design */
    @media (max-height: 600px) {
      .header {
        padding: var(--space-sm) var(--space-md);
      }

      .content {
        padding: var(--space-sm) var(--space-md);
      }
    }

    /* Toggle Switch */
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 22px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--border);
      transition: var(--transition-fast);
      border-radius: 22px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: var(--transition-fast);
      border-radius: 50%;
    }

    input:checked + .toggle-slider {
      background-color: var(--interactive);
    }

    input:checked + .toggle-slider:before {
      transform: translateX(18px);
    }

    /* Quick Actions Bar */
    .quick-actions-bar {
      display: flex;
      gap: var(--space-sm);
      padding: var(--space-md);
      background: var(--surface);
      border-radius: var(--radius-md);
      align-items: center;
      justify-content: space-between;
    }

    .quick-actions-bar .button {
      flex: 1;
    }

    .quick-actions-bar .button-ghost {
      flex: 0 0 auto;
    }

    .tab-button {
      padding: var(--spacing-03) var(--spacing-05) calc(var(--spacing-03) + 1px);
      background: transparent;
      border: none;
      border-bottom: 2px solid transparent;
      color: var(--text-secondary);
      font-size: var(--font-size-md);
      font-weight: var(--font-weight-medium);
      cursor: pointer;
      transition: color var(--transition-fast), border-color var(--transition-fast);
      position: relative;
      margin-bottom: -1px;
    }

    .tab-button:hover:not(.active) {
      color: var(--text-primary);
      border-bottom-color: var(--border-strong);
    }

    .tab-button.active {
      color: var(--interactive);
      border-bottom-color: var(--interactive);
    }

    .tab-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Tab Content */
    .tab-content {
      display: none;
      flex: 1;
      overflow-y: auto;
    }

    .tab-content.active {
      display: flex;
      flex-direction: column;
    }

    /* Chat Interface Styles - Cleaner Layout */
    .chat-wrapper {
      display: flex;
      flex-direction: column;
      height: calc(100vh - 200px);
      max-height: 600px;
    }

    .chat-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 0 var(--space-sm);
      border-bottom: 1px solid var(--border);
      background: var(--background);
      min-height: 40px;
    }

    .chat-title h2 {
      font-size: 14px;
      font-weight: 600;
      margin: 0;
      color: var(--text-primary);
    }

    .component-context {
      background: var(--primary-light);
      border: 1px solid var(--primary);
      border-radius: var(--radius-md);
      padding: var(--space-sm);
      margin: var(--space-sm) 0;
    }

    .context-badge {
      font-size: 11px;
      font-weight: 600;
      color: var(--primary);
      margin-bottom: var(--space-xs);
    }

    .context-info {
      font-size: 11px;
      color: var(--text-secondary);
    }

    .chat-empty {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: var(--space-md);
    }

    .chat-empty-content {
      text-align: center;
      max-width: 350px;
    }

    .chat-empty-icon {
      font-size: 36px;
      opacity: 0.2;
      display: block;
      margin-bottom: var(--space-sm);
    }

    .chat-empty-text h3 {
      font-size: 14px;
      font-weight: 600;
      margin: 0 0 var(--space-xs) 0;
      color: var(--text-primary);
    }

    .chat-empty-text p {
      font-size: 12px;
      color: var(--text-tertiary);
      margin: 0 0 var(--space-md) 0;
      line-height: 1.4;
    }

    .chat-suggestions {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-xs);
      justify-content: center;
    }

    .chat-suggestion {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      padding: var(--spacing-02) var(--spacing-03);
      font-size: var(--font-size-xs);
      color: var(--text-primary);
      cursor: pointer;
      transition: background var(--transition-fast), border-color var(--transition-fast);
    }

    .chat-suggestion:hover {
      background: var(--interactive-light);
      border-color: var(--interactive);
      color: var(--interactive);
    }

    .chat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: var(--space-md) 0;
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
    }

    .chat-message {
      display: flex;
      flex-direction: column;
      max-width: 85%;
      animation: fadeInUp 0.3s ease;
    }

    .chat-message.user {
      align-self: flex-end;
    }

    .chat-message.assistant {
      align-self: flex-start;
    }

    .chat-message-content {
      padding: var(--space-sm) var(--space-md);
      border-radius: var(--radius-md);
      font-size: 13px;
      line-height: 1.5;
      word-wrap: break-word;
    }

    .chat-message.user .chat-message-content {
      background: var(--interactive);
      color: var(--text-on-color);
      border-bottom-right-radius: var(--radius-sm);
    }

    .chat-message.assistant .chat-message-content {
      background: var(--surface);
      color: var(--text-primary);
      border: 1px solid var(--border);
      border-bottom-left-radius: var(--radius-sm);
    }

    .chat-message-meta {
      font-size: 11px;
      color: var(--text-tertiary);
      margin-top: var(--space-xs);
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }

    .chat-message.user .chat-message-meta {
      justify-content: flex-end;
    }

    .chat-message.assistant .chat-message-meta {
      justify-content: flex-start;
    }

    .chat-sources {
      margin-top: var(--space-sm);
      padding: var(--space-sm);
      background: var(--primary-light);
      border-radius: var(--radius-sm);
      font-size: 11px;
    }

    .chat-sources-title {
      font-weight: 600;
      color: var(--primary);
      margin-bottom: var(--space-xs);
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }

    .chat-source {
      padding: var(--space-xs);
      margin-bottom: var(--space-xs);
      background: white;
      border-radius: var(--radius-sm);
      border-left: 3px solid var(--primary);
    }

    .chat-source:last-child {
      margin-bottom: 0;
    }

    .chat-source-title {
      font-weight: 500;
      color: var(--text-primary);
      margin-bottom: 2px;
      font-size: 11px;
    }

    .chat-source-content {
      color: var(--text-secondary);
      font-size: 10px;
      line-height: 1.4;
    }

    .chat-input-container {
      border-top: 2px solid var(--border);
      padding: var(--space-md) 0 0;
    }

    .chat-input-wrapper {
      display: flex;
      gap: var(--space-sm);
      align-items: flex-end;
    }

    .chat-input-wrapper textarea {
      flex: 1;
      min-height: 36px;
      max-height: 120px;
      resize: none;
      font-size: 13px;
      line-height: 1.4;
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      background: var(--background);
      transition: all var(--transition-fast);
      font-family: inherit;
    }

    .chat-input-wrapper textarea:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px var(--primary-light);
    }

    .chat-input-wrapper textarea:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .chat-send-button {
      padding: var(--spacing-03);
      min-width: 36px;
      height: 36px;
      background: var(--interactive);
      color: var(--text-on-color);
      border: none;
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: background var(--transition-fast);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .chat-send-button:hover:not(:disabled) {
      background: var(--interactive-hover);
    }

    .chat-send-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .chat-status {
      margin-top: var(--space-sm);
      padding: var(--space-xs) var(--space-sm);
      background: var(--primary-light);
      border-radius: var(--radius-sm);
      font-size: 11px;
      color: var(--primary);
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }

    .chat-status::before {
      content: '';
      width: 12px;
      height: 12px;
      border: 2px solid var(--primary);
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    /* Standard Article/Prose Styling for Chat Content */
    .chat-article {
      line-height: 1.5;
    }

    .chat-article h2 {
      font-size: 14px;
      font-weight: 600;
      margin: 0.9em 0 0.65em 0;
      color: var(--text-primary);
    }

    .chat-article h3 {
      font-size: 13px;
      font-weight: 600;
      margin: 0.85em 0 0.6em 0;
      color: var(--text-primary);
    }

    .chat-article h4 {
      font-size: 12px;
      font-weight: 600;
      margin: 0.6em 0 0.3em 0;
      color: var(--text-primary);
    }

    .chat-article ul,
    .chat-article ol {
      margin: 0.2em 0;
      padding-left: 1.8em;
    }

    .chat-article li {
      margin-bottom: 0.1em;
    }

    .chat-article code {
      background: rgba(0, 0, 0, 0.08);
      padding: 0.1em 0.3em;
      border-radius: 2px;
      font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
      font-size: 0.9em;
    }

    .chat-article strong {
      font-weight: 600;
    }

    .chat-article p {
      margin: 0.4em 0 0.6em;
    }

    /* Remove top margin from first element and bottom margin from last element */
    .chat-article > *:first-child {
      margin-top: 0;
    }

    .chat-article > *:last-child {
      margin-bottom: 0;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes dots {
      0%, 20% { opacity: 0; }
      50% { opacity: 1; }
      80%, 100% { opacity: 0; }
    }

    @keyframes chatLoadingDot {
      0%, 80%, 100% {
        transform: scale(0.8);
        opacity: 0.5;
      }
      40% {
        transform: scale(1);
        opacity: 1;
      }
    }

    .loading-dots {
      display: inline-flex;
      gap: 2px;
    }

    .loading-dots span {
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: var(--text-tertiary);
      animation: dots 1.4s infinite ease-in-out;
    }

    .loading-dots span:nth-child(1) { animation-delay: -0.32s; }
    .loading-dots span:nth-child(2) { animation-delay: -0.16s; }
    .loading-dots span:nth-child(3) { animation-delay: 0s; }

    /* (duplicate chat-suggestion removed - consolidated above) */

    /* Select node button styles */
    .select-node-btn {
      background: var(--interactive);
      color: var(--text-on-color);
      border: none;
      border-radius: var(--radius-sm);
      padding: var(--spacing-02);
      cursor: pointer;
      transition: background var(--transition-fast);
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 26px;
      height: 26px;
      margin-left: auto;
      flex-shrink: 0;
    }

    .select-node-btn:hover {
      background: var(--interactive-hover);
    }

    .select-node-btn:active {
      background: var(--interactive-active);
    }

    .select-node-btn svg {
      width: 14px;
      height: 14px;
    }

    /* Token item layout - select button accommodation */

    .token-item-compact .token-details {
      flex: 1;
      min-width: 0; /* Allow text to truncate */
    }

    .chat-loading {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
      padding: var(--space-sm) var(--space-md);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      border-bottom-left-radius: var(--radius-sm);
    }

    .chat-loading-dots {
      display: flex;
      gap: 3px;
    }

    .chat-loading-dot {
      width: 4px;
      height: 4px;
      background: var(--text-tertiary);
      border-radius: 50%;
      animation: chatLoadingDot 1.4s ease-in-out infinite both;
    }

    .chat-loading-dot:nth-child(1) { animation-delay: -0.32s; }
    .chat-loading-dot:nth-child(2) { animation-delay: -0.16s; }

    /* Confirmation Modal Styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(22, 22, 22, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: var(--z-modal);
      opacity: 0;
      visibility: hidden;
      transition: opacity var(--transition-fast), visibility var(--transition-fast);
    }

    .modal-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .modal-container {
      background: var(--surface);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-lg);
      width: 90%;
      max-width: 480px;
      max-height: 80vh;
      overflow: hidden;
      transform: scale(0.95);
      transition: transform var(--transition-fast);
    }

    .modal-overlay.active .modal-container {
      transform: scale(1);
    }

    .modal-header {
      padding: var(--space-md);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .modal-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      margin: 0;
    }

    .modal-close {
      background: none;
      border: none;
      cursor: pointer;
      color: var(--text-tertiary);
      padding: 4px;
      border-radius: var(--radius-sm);
      transition: all var(--transition-fast);
    }

    .modal-close:hover {
      background: var(--surface);
      color: var(--text-primary);
    }

    .modal-body {
      padding: var(--space-md);
      overflow-y: auto;
      max-height: 50vh;
    }

    .modal-footer {
      padding: var(--space-md);
      border-top: 1px solid var(--border);
      display: flex;
      gap: var(--space-sm);
      justify-content: flex-end;
    }

    .preview-box {
      background: var(--surface);
      border-radius: var(--radius-md);
      padding: var(--space-sm) var(--space-md);
      margin-bottom: var(--space-sm);
    }

    .preview-label {
      font-size: 10px;
      text-transform: uppercase;
      color: var(--text-tertiary);
      margin-bottom: 4px;
    }

    .preview-value {
      font-size: 13px;
      color: var(--text-primary);
      font-family: 'SF Mono', Monaco, monospace;
    }

    .preview-arrow {
      text-align: center;
      color: var(--primary);
      font-size: 16px;
      margin: var(--space-xs) 0;
    }

    /* Fix Button Styles */
    .fix-btn {
      font-size: var(--font-size-xs);
      padding: var(--spacing-02) var(--spacing-04);
      background: var(--interactive-light);
      color: var(--interactive);
      border: 1px solid var(--interactive);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: background var(--transition-fast), color var(--transition-fast);
      white-space: nowrap;
      min-height: 24px;
    }

    .fix-btn:hover {
      background: var(--interactive);
      color: var(--text-on-color);
    }

    .fix-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .token-actions {
      display: flex;
      gap: 4px;
      align-items: center;
      margin-left: auto;
    }

    /* Fix Summary Bar (auto-fix actions in analysis results) */
    .fix-summary-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--interactive-light);
      border: 1px solid var(--interactive);
      border-left: 4px solid var(--interactive);
      border-radius: var(--radius-sm);
      padding: var(--spacing-03) var(--spacing-04);
      margin-bottom: var(--spacing-04);
      overflow: hidden;
      flex-wrap: wrap;
      gap: 6px;
    }

    .fix-summary-stats {
      display: flex;
      gap: 8px;
      align-items: center;
      font-size: 11px;
      color: var(--text-secondary);
    }

    .fix-summary-stats .stat-chip {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 2px 8px;
      font-size: 10px;
      white-space: nowrap;
    }

    .quick-actions-btn {
      font-size: var(--font-size-xs);
      padding: var(--spacing-02) var(--spacing-04);
      background: var(--interactive);
      color: var(--text-on-color);
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: background var(--transition-fast);
      white-space: nowrap;
      font-weight: var(--font-weight-medium);
      min-height: 24px;
    }

    .quick-actions-btn:hover {
      background: var(--interactive-hover);
    }

    .quick-actions-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Batch Action Bar (token section) */
    .batch-action-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--warning-bg);
      border: 1px solid var(--warning);
      border-left: 4px solid var(--warning);
      border-radius: var(--radius-sm);
      padding: var(--spacing-03) var(--spacing-04);
      margin-bottom: var(--spacing-04);
      font-size: var(--font-size-xs);
    }

    .batch-action-bar .batch-label {
      color: var(--text-secondary);
      font-weight: 500;
    }

    /* Metadata Action Bar */
    .metadata-action-bar {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      background: var(--surface-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      padding: 8px 12px;
      margin-bottom: 12px;
    }

    .metadata-action-bar .action-label {
      font-size: 11px;
      color: var(--text-secondary);
      flex: 1;
      min-width: 0;
    }

    .metadata-action-bar .audit-action-button {
      flex-shrink: 0;
    }

    /* Naming Issue Arrow */
    .naming-issue-arrow {
      color: var(--primary);
      font-weight: 600;
      margin: 0 6px;
      font-size: 12px;
    }

    /* Layer Naming Tree */
    .naming-tree-summary {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 8px;
      background: var(--surface-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      margin-bottom: 8px;
      font-size: 11px;
      color: var(--text-secondary);
    }
    .naming-tree-summary .severity-counts {
      display: flex;
      gap: 8px;
    }
    .naming-tree-summary .sev-count {
      display: flex;
      align-items: center;
      gap: 3px;
      font-size: 10px;
      font-weight: 500;
    }
    .naming-tree-toggle {
      background: none;
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 2px 8px;
      font-size: 10px;
      color: var(--primary);
      cursor: pointer;
      transition: var(--transition-fast);
    }
    .naming-tree-toggle:hover {
      background: var(--primary-light);
      border-color: var(--primary);
    }
    .naming-tree-group {
      margin-bottom: 6px;
    }
    .naming-tree-group-header {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 0;
      font-size: 10px;
      font-weight: 600;
      color: var(--text-secondary);
      cursor: pointer;
      user-select: none;
    }
    .naming-tree-group-header:hover {
      color: var(--text-primary);
    }
    .naming-tree-group-header .tree-arrow {
      display: inline-block;
      transition: transform var(--transition-fast);
      font-size: 8px;
      width: 12px;
      text-align: center;
    }
    .naming-tree-group-header .tree-arrow.collapsed {
      transform: rotate(-90deg);
    }
    .naming-tree-group-header .group-count {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0 5px;
      font-size: 9px;
      font-weight: 500;
      color: var(--text-tertiary);
      margin-left: auto;
    }
    .naming-tree-items {
      overflow: hidden;
      transition: max-height var(--transition-base);
    }
    .naming-tree-items.collapsed {
      max-height: 0 !important;
    }
    .naming-tree-item {
      display: flex;
      align-items: flex-start;
      gap: 6px;
      padding: 4px 0 4px 16px;
      border-left: 1px solid var(--border);
      margin-left: 5px;
      cursor: pointer;
    }
    .naming-tree-item:hover {
      background: var(--interactive-light, rgba(0, 122, 255, 0.06));
      border-radius: var(--radius-sm);
    }
    .naming-tree-item .audit-content {
      flex: 1;
      min-width: 0;
    }

    /* Copy Button */
    .copy-btn {
      background: transparent;
      border: 1px solid transparent;
      border-radius: var(--radius-sm);
      padding: 3px 5px;
      cursor: pointer;
      color: var(--text-tertiary);
      transition: all var(--transition-fast);
      font-size: 12px;
      line-height: 1;
    }

    .copy-btn:hover {
      border-color: var(--border);
      color: var(--text-primary);
      background: var(--surface);
    }

    .copy-btn.copied {
      border-color: var(--success);
      color: var(--success);
    }

    /* Fix Applied Animation */
    @keyframes fixAppliedFlash {
      0% { background-color: transparent; }
      30% { background-color: rgba(52, 199, 89, 0.15); }
      100% { background-color: transparent; }
    }

    .fix-applied-success {
      animation: fixAppliedFlash 1.2s ease-out;
    }

    .fix-btn.fix-applied {
      background: var(--success);
      color: var(--text-on-color);
      border-color: var(--success);
      pointer-events: none;
    }

    .token-item-compact.warning[onclick]:hover {
      background: var(--interactive-light, rgba(0, 122, 255, 0.06));
      border-radius: var(--radius-sm);
    }

    .token-item-compact.fix-applied-success {
      opacity: 0.4;
    }


    /* Inline icon system (Lucide stroke-based) */
    .ico {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      vertical-align: -3px;
      flex-shrink: 0;
    }

    .ico svg {
      width: 100%;
      height: 100%;
      fill: none;
      stroke: currentColor;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    /* Provider indicator dots */
    .provider-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      vertical-align: middle;
      margin-right: 4px;
    }
    .provider-dot.anthropic { background: #7C3AED; }
    .provider-dot.openai { background: #10A37F; }
    .provider-dot.google { background: #4285F4; }

    /* Custom scrollbar (thin, Carbon-style) */
    ::-webkit-scrollbar {
      width: 6px;
    }
    ::-webkit-scrollbar-track {
      background: transparent;
    }
    ::-webkit-scrollbar-thumb {
      background: var(--surface-alt);
      border-radius: 3px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: var(--border-strong);
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <div class="plugin-title">
        <div class="plugin-icon">FL</div>
        <h1 class="plugin-name">FigmaLint</h1>
      </div>
      <p class="plugin-description">AI-powered component analysis and design systems chat.</p>
    </div>

    <!-- Tab Navigation -->
    <div class="tabs-navigation">
      <button class="tab-button active" id="tab-analyze" onclick="switchTab('analyze')">
        Analyze
      </button>
      <button class="tab-button" id="tab-chat" onclick="switchTab('chat')">
        Chat
      </button>
    </div>

        <!-- Tab Content: Analyze -->
    <div class="tab-content active" id="content-analyze">
      <div class="content">
        <!-- Quick Actions Bar (shown when API key is saved) -->
        <div class="quick-actions-bar" id="quick-actions" style="display: none;">
          <button id="quick-analyze-component" class="button button-primary">
            <span>Analyze Component</span>
          </button>
          <button id="show-config" class="button button-ghost" title="Show configuration">
            <svg width="16" height="16" viewBox="0 0 512 512" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M424.5,216.5h-15.2c-12.4,0-22.8-10.7-22.8-23.4c0-6.4,2.7-12.2,7.5-16.5l9.8-9.6c9.7-9.6,9.7-25.3,0-34.9l-22.3-22.1  c-4.4-4.4-10.9-7-17.5-7c-6.6,0-13,2.6-17.5,7l-9.4,9.4c-4.5,5-10.5,7.7-17,7.7c-12.8,0-23.5-10.4-23.5-22.7V89.1  c0-13.5-10.9-25.1-24.5-25.1h-30.4c-13.6,0-24.4,11.5-24.4,25.1v15.2c0,12.3-10.7,22.7-23.5,22.7c-6.4,0-12.3-2.7-16.6-7.4l-9.7-9.6  c-4.4-4.5-10.9-7-17.5-7s-13,2.6-17.5,7L110,132c-9.6,9.6-9.6,25.3,0,34.8l9.4,9.4c5,4.5,7.8,10.5,7.8,16.9  c0,12.8-10.4,23.4-22.8,23.4H89.2c-13.7,0-25.2,10.7-25.2,24.3V256v15.2c0,13.5,11.5,24.3,25.2,24.3h15.2  c12.4,0,22.8,10.7,22.8,23.4c0,6.4-2.8,12.4-7.8,16.9l-9.4,9.3c-9.6,9.6-9.6,25.3,0,34.8l22.3,22.2c4.4,4.5,10.9,7,17.5,7  c6.6,0,13-2.6,17.5-7l9.7-9.6c4.2-4.7,10.2-7.4,16.6-7.4c12.8,0,23.5,10.4,23.5,22.7v15.2c0,13.5,10.8,25.1,24.5,25.1h30.4  c13.6,0,24.4-11.5,24.4-25.1v-15.2c0-12.3,10.7-22.7,23.5-22.7c6.4,0,12.4,2.8,17,7.7l9.4,9.4c4.5,4.4,10.9,7,17.5,7  c6.6,0,13-2.6,17.5-7l22.3-22.2c9.6-9.6,9.6-25.3,0-34.9l-9.8-9.6c-4.8-4.3-7.5-10.2-7.5-16.5c0-12.8,10.4-23.4,22.8-23.4h15.2  c13.6,0,23.3-10.7,23.3-24.3V256v-15.2C447.8,227.2,438.1,216.5,424.5,216.5z M336.8,256L336.8,256c0,44.1-35.7,80-80,80  c-44.3,0-80-35.9-80-80l0,0l0,0c0-44.1,35.7-80,80-80C301.1,176,336.8,211.9,336.8,256L336.8,256z" fill="currentColor"/>
            </svg>
          </button>
        </div>

        <!-- API Key Configuration -->
        <div class="card" id="api-key-card">
          <div class="card-header">
            <h2 class="card-title">Configuration</h2>
            <button id="hide-config" class="button button-ghost" style="display: none; padding: 4px 8px; font-size: 11px;">
              <span>Hide</span>
            </button>
          </div>

          <div id="config-content">
            <!-- Provider Selection -->
            <div class="form-group">
              <label for="provider-select">AI Provider</label>
              <select id="provider-select">
                <option value="anthropic">Anthropic (Claude)</option>
                <option value="openai">OpenAI (GPT)</option>
                <option value="google">Google (Gemini)</option>
              </select>
              <p class="card-subtitle">Select your preferred AI provider</p>
            </div>

            <!-- API Key Input -->
            <div class="form-group">
              <label for="api-key"><span id="api-key-label">Claude</span> API Key</label>
              <div class="input-wrapper">
                <input
                  type="password"
                  id="api-key"
                  placeholder="sk-ant-..."
                  autocomplete="off"
                >
                <span class="input-icon"><svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor"><path d="M4 4v2h-.25A1.75 1.75 0 002 7.75v5.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 13.25v-5.5A1.75 1.75 0 0012.25 6H12V4a4 4 0 10-8 0zm6 2V4a2 2 0 10-4 0v2h4zm-5.25 2h6.5a.25.25 0 01.25.25v5.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-5.5a.25.25 0 01.25-.25z"/></svg></span>
              </div>
              <p class="card-subtitle" id="api-key-hint">Your API key is stored securely in this session</p>
            </div>

            <!-- Model Selection (dynamic based on provider) -->
            <div class="form-group">
              <label for="model-select"><span id="model-label">Claude</span> Model</label>
              <select id="model-select">
                <!-- Anthropic (Claude) Models -->
                <optgroup label="Anthropic (Claude)" id="anthropic-models">
                  <option value="claude-opus-4-5-20251218">Claude Opus 4.5 (Flagship - Advanced Reasoning)</option>
                  <option value="claude-sonnet-4-5-20250929" selected>Claude Sonnet 4.5 (Recommended - Best Value)</option>
                  <option value="claude-haiku-4-5-20251001">Claude Haiku 4.5 (Fast - Economy)</option>
                </optgroup>
                <!-- OpenAI (GPT) Models -->
                <optgroup label="OpenAI (GPT)" id="openai-models" style="display: none;">
                  <option value="gpt-5.2" disabled>GPT-5.2 (Flagship)</option>
                  <option value="gpt-5.2-pro" disabled>GPT-5.2 Pro (Extended Reasoning)</option>
                  <option value="gpt-5-mini" disabled>GPT-5 Mini (Fast - Economy)</option>
                </optgroup>
                <!-- Google (Gemini) Models -->
                <optgroup label="Google (Gemini)" id="google-models" style="display: none;">
                  <option value="gemini-3-pro-preview" disabled>Gemini 3 Pro (Flagship - Multimodal)</option>
                  <option value="gemini-2.5-pro" disabled>Gemini 2.5 Pro (Recommended)</option>
                  <option value="gemini-2.5-flash" disabled>Gemini 2.5 Flash (Fast - Economy)</option>
                </optgroup>
              </select>
              <p class="card-subtitle">Choose the model that works best for your component analysis</p>
            </div>

            <div class="button-group mt-md">
              <button id="save-key" class="button button-secondary">
                <span>Save Key</span>
              </button>
              <button id="analyze-component" class="button button-primary" disabled>
                <span>Analyze Component</span>
              </button>
            </div>
          </div>

          <!-- Status Message -->
          <div id="status-container" class="hidden">
            <div class="status-banner" id="status">
              <span class="status-icon" id="status-icon"></span>
              <span id="status-text">Ready to analyze</span>
            </div>
          </div>
        </div>

        <!-- Batch Mode Toggle (shown when multiple components selected) -->
        <div class="batch-toggle hidden" id="batch-mode-toggle">
          <span class="ico"><svg viewBox="0 0 16 16" fill="currentColor"><path d="M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8z"/><path d="M8 4.5a3.5 3.5 0 100 7 3.5 3.5 0 000-7zM6 8a2 2 0 114 0 2 2 0 01-4 0z"/><circle cx="8" cy="8" r="1"/></svg></span>
          <span>Multiple components selected</span>
          <label class="toggle-switch">
            <input type="checkbox" id="batch-mode-switch">
            <span class="toggle-slider"></span>
          </label>
          <span>Batch Mode</span>
        </div>

        <!-- Analysis Results -->
        <div id="analysis-results" class="hidden">
          <!-- Audit View -->
          <div class="collapsible">
            <div class="collapsible-header active" onclick="toggleCollapsible(this)">
              <div class="collapsible-title">
                <span class="collapsible-icon"></span>
                <span>Component Audit</span>
                <div class="tooltip">
                  <div class="info-icon">i</div>
                  <span class="tooltiptext">
                    <strong>Component Audit</strong><br>
                    Analyzes your component for common issues that can cause problems during development. Checks for missing interactive states, accessibility compliance, naming clarity, and design system consistency.
                  </span>
                </div>
              </div>
              <span id="audit-score" class="status-banner status-info" style="padding: 2px 8px; font-size: 11px;">
                <span>Score: --</span>
              </span>
            </div>
            <div class="collapsible-content active" id="audit-content">
              <div class="skeleton"></div>
              <div class="skeleton" style="width: 80%;"></div>
              <div class="skeleton" style="width: 60%;"></div>
            </div>
          </div>



          <!-- Property Cheat Sheet -->
          <div class="collapsible">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
              <div class="collapsible-title">
                <span class="collapsible-icon"></span>
                <span>Property Cheat Sheet</span>
                <div class="tooltip">
                  <div class="info-icon">i</div>
                  <span class="tooltiptext">
                    <strong>Property Cheat Sheet</strong><br>
                    Shows the actual properties (variants) your component has and their available values. This helps developers understand exactly what options the component supports and what the default values should be.
                  </span>
                </div>
              </div>
            </div>
            <div class="collapsible-content" id="property-cheatsheet">
              <div class="skeleton"></div>
              <div class="skeleton" style="width: 70%;"></div>
            </div>
          </div>

          <!-- Token Analysis -->
          <div class="collapsible">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
              <div class="collapsible-title">
                <span class="collapsible-icon"></span>
                <span>Token Analysis</span>
                <div class="tooltip">
                  <div class="info-icon">i</div>
                  <span class="tooltiptext">
                    <strong>Token Analysis</strong><br>
                    Analyzes colors, spacing, typography, and effects to show which use design tokens versus hard-coded values. Design tokens make your components more consistent, maintainable, and easier to theme or rebrand.
                  </span>
                </div>
              </div>
            </div>
            <div class="collapsible-content" id="token-suggestions">
              <div class="skeleton"></div>
              <div class="skeleton" style="width: 90%;"></div>
            </div>
          </div>

          <!-- AI Interpretation -->
          <div class="collapsible">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
              <div class="collapsible-title">
                <span class="collapsible-icon"></span>
                <span>AI Interpretation</span>
                <div class="tooltip">
                  <div class="info-icon">i</div>
                  <span class="tooltiptext">
                    <strong>AI Interpretation</strong><br>
                    Describes how AI tools would read and interpret this component. Shows what an AI would understand from the current structure, naming, and properties  and where clarity could be improved for better code generation.
                  </span>
                </div>
              </div>
            </div>
            <div class="collapsible-content" id="mcp-readiness">
              <div class="skeleton"></div>
              <div class="skeleton" style="width: 75%;"></div>
              <div class="skeleton" style="width: 90%;"></div>
            </div>
          </div>

          <!-- Component Metadata (moved up one position) -->
          <div class="collapsible">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
              <div class="collapsible-title">
                <span class="collapsible-icon"></span>
                <span>Component Metadata</span>
              </div>
            </div>
            <div class="collapsible-content" id="metadata-content">
              <div class="skeleton"></div>
              <div class="skeleton" style="width: 85%;"></div>
            </div>
          </div>

          <!-- Developer Handoff (moved to bottom) -->
          <div class="collapsible">
            <div class="collapsible-header" onclick="toggleCollapsible(this)">
              <div class="collapsible-title">
                <span class="collapsible-icon"></span>
                <span>Developer Handoff</span>
                <div class="tooltip">
                  <div class="info-icon">i</div>
                  <span class="tooltiptext">
                    <strong>Developer Handoff</strong><br>
                    Provides structured component documentation in formats developers expect (JSON, TypeScript, documentation). This speeds up implementation and reduces back-and-forth communication during the design-to-code process.
                  </span>
                </div>
              </div>
            </div>
            <div class="collapsible-content" id="developer-export">
              <div class="export-options" style="margin-bottom: var(--space-md);">
                <select id="export-format" class="w-full">
                  <option value="json">JSON: Complete component metadata</option>
                  <option value="markdown" selected>Markdown: Developer documentation</option>
                </select>
                <button class="button button-secondary" id="export-metadata" disabled>
                  Export for Developers
                </button>
              </div>
              <div class="skeleton"></div>
              <div class="skeleton" style="width: 80%;"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Tab Content: Chat -->
    <div class="tab-content" id="content-chat">
      <div class="content">
        <div class="chat-wrapper">
          <!-- Chat Header -->
          <div class="chat-header">
            <div class="chat-title">
              <h2>Design Systems Chat</h2>
            </div>
            <button class="button button-ghost" id="clear-chat" title="Clear chat history">
              <span class="ico"><svg viewBox="0 0 16 16" fill="currentColor"><path d="M11 1.75V3h2.25a.75.75 0 010 1.5H2.75a.75.75 0 010-1.5H5V1.75C5 .784 5.784 0 6.75 0h2.5C10.216 0 11 .784 11 1.75zM6.5 1.75a.25.25 0 01.25-.25h2.5a.25.25 0 01.25.25V3h-3V1.75zM4.496 6.675l.66 6.6a.25.25 0 00.249.225h5.19a.25.25 0 00.249-.225l.66-6.6a.75.75 0 011.492.15l-.66 6.6A1.748 1.748 0 0110.595 15h-5.19a1.75 1.75 0 01-1.741-1.575l-.66-6.6a.75.75 0 111.492-.15z"/></svg></span> Clear
            </button>
          </div>

          <!-- Component Context (if available) -->
          <div id="component-context-indicator" class="hidden component-context">
            <div class="context-badge">
              <span class="ico"><svg viewBox="0 0 16 16" fill="currentColor"><path d="M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8z"/><path d="M8 4.5a3.5 3.5 0 100 7 3.5 3.5 0 000-7zM6 8a2 2 0 114 0 2 2 0 01-4 0z"/><circle cx="8" cy="8" r="1"/></svg></span> Component Context Available
            </div>
            <div id="current-component-info" class="context-info">
              <!-- Component info will be injected here -->
            </div>
          </div>

          <!-- Chat Empty State -->
          <div id="chat-empty" class="chat-empty">
            <div class="chat-empty-content">
              <span class="chat-empty-icon"><svg viewBox="0 0 16 16" fill="currentColor" width="24" height="24"><path d="M1.75 1h12.5c.966 0 1.75.784 1.75 1.75v8.5A1.75 1.75 0 0114.25 13H8.06l-2.573 2.573A1.458 1.458 0 013 14.543V13H1.75A1.75 1.75 0 010 11.25v-8.5C0 1.784.784 1 1.75 1zm.25 1.75v8.5c0 .138.112.25.25.25h2a.75.75 0 01.75.75v2.19l2.72-2.72a.749.749 0 01.53-.22h6a.25.25 0 00.25-.25v-8.5a.25.25 0 00-.25-.25H2a.25.25 0 00-.25.25z"/></svg></span>
              <div class="chat-empty-text">
                <h3>Ask me about design systems!</h3>
                <p>I have access to comprehensive design systems knowledge and can help with components, tokens, patterns, and best practices.</p>
              </div>

              <!-- Simplified Suggestions -->
              <div id="chat-suggestions" class="chat-suggestions">
                <!-- Suggestions will be populated by JavaScript -->
              </div>
            </div>
          </div>

          <!-- Chat Messages Container -->
          <div id="chat-container" class="chat-container hidden">
            <div id="chat-messages" class="chat-messages">
              <!-- Chat messages will be added here -->
            </div>
          </div>

          <!-- Chat Input -->
          <div class="chat-input-container">
            <div class="chat-input-wrapper">
              <textarea
                id="chat-input"
                placeholder="Ask about design systems, components, tokens, or best practices..."
                rows="1"
                disabled
              ></textarea>
              <button id="send-chat" class="chat-send-button" disabled title="Send message">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <line x1="22" y1="2" x2="11" y2="13"></line>
                  <polygon points="22,2 15,22 11,13 2,9"></polygon>
                </svg>
              </button>
            </div>
            <div id="chat-status" class="chat-status hidden">
              <span class="chat-status-text">Thinking...</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Confirmation Modal -->
    <div class="modal-overlay" id="fix-modal">
      <div class="modal-container">
        <div class="modal-header">
          <h3 class="modal-title" id="modal-title">Confirm Fix</h3>
          <button class="modal-close" onclick="hideFixModal()"></button>
        </div>
        <div class="modal-body" id="modal-body">
          <!-- Preview content will be inserted here -->
        </div>
        <div class="modal-footer">
          <button class="button button-secondary" onclick="hideFixModal()">Cancel</button>
          <button class="button button-primary" id="modal-confirm-btn" onclick="confirmFix()">Apply Fix</button>
        </div>
      </div>
    </div>

    <!-- Footer -->
    <div class="footer-links">
      <a href="#" id="clear-api-key" class="footer-link hidden">Clear saved API key</a>
    </div>
  </div>

  <!-- Enhanced JavaScript -->
  <script>
    console.log('Enhanced UI JavaScript loading...');

    // Shared utility functions
    function toTitleCase(str) {
      return str
        .replace(/([A-Z])/g, ' $1') // Add space before capital letters
        .split(/[\s_-]+/) // Split on spaces, underscores, or hyphens
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join(' ')
        .trim();
    }

    // SVG Icon library for professional UI
    const ICO = {
      info:          '<span class="ico" style="color:var(--info)"><svg viewBox="0 0 24 24" role="img" aria-label="Info"><title>Info</title><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg></span>',
      checkCircle:   '<span class="ico" style="color:var(--success)"><svg viewBox="0 0 24 24" role="img" aria-label="Pass"><title>Pass</title><circle cx="12" cy="12" r="10"/><path d="m9 12 2 2 4-4"/></svg></span>',
      xCircle:       '<span class="ico" style="color:var(--error)"><svg viewBox="0 0 24 24" role="img" aria-label="Fail"><title>Fail</title><circle cx="12" cy="12" r="10"/><path d="m15 9-6 6"/><path d="m9 9 6 6"/></svg></span>',
      warnTriangle:  '<span class="ico" style="color:var(--warning-text)"><svg viewBox="0 0 24 24" role="img" aria-label="Warning"><title>Warning</title><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg></span>',
    };

    // Filter out wrapper/boundary elements from token scoring
    function filterWrapperElements(tokenSummary) {
      // For now, apply a conservative filter that reduces hard-coded penalties
      // for likely wrapper elements. This is a heuristic-based approach.

      // If we have token data available, try to identify wrapper patterns
      if (window.currentAnalysisData && window.currentAnalysisData.tokens) {
        let wrapperTokenCount = 0;
        const tokens = window.currentAnalysisData.tokens;

        // Look for patterns that suggest wrapper/boundary elements:
        // 1. Dashed/dotted strokes (common for component boundaries)
        // 2. Arbitrary border radius on containers
        // 3. Specific color patterns that suggest organizational use

        ['colors', 'borders', 'effects'].forEach(category => {
          if (tokens[category]) {
            tokens[category].forEach(token => {
              // Check if this looks like a wrapper element
              if (isLikelyWrapperElement(token)) {
                wrapperTokenCount++;
              }
            });
          }
        });

        console.log(`[DEBUG][WRAPPER FILTER] Identified ${wrapperTokenCount} likely wrapper tokens`);

        // Reduce hard-coded count by estimated wrapper elements, but be conservative
        const filteredHardCoded = Math.max(0, tokenSummary.hardCodedValues - Math.min(wrapperTokenCount, Math.floor(tokenSummary.hardCodedValues * 0.3)));
        const filteredTotal = Math.max(1, tokenSummary.totalTokens - Math.min(wrapperTokenCount, Math.floor(tokenSummary.totalTokens * 0.3)));

        return {
          hardCodedValues: filteredHardCoded,
          totalTokens: filteredTotal,
          actualTokens: tokenSummary.actualTokens,
          wrapperElementsFiltered: wrapperTokenCount
        };
      }

      // Fallback: no filtering if we can't detect patterns
      return {
        hardCodedValues: tokenSummary.hardCodedValues,
        totalTokens: tokenSummary.totalTokens,
        actualTokens: tokenSummary.actualTokens,
        wrapperElementsFiltered: 0
      };
    }

        // Heuristic to detect wrapper/boundary elements
    function isLikelyWrapperElement(token) {
      const context = token.context || {};
      const value = token.value || '';

      // Handle context as object (which it actually is)
      const contextStr = typeof context === 'string' ? context :
        `${context.nodeType || ''} ${context.nodeName || ''} ${context.property || ''}`.toLowerCase();

      // Check for dashed/dotted borders (common wrapper pattern)
      if (contextStr.includes('stroke') && (contextStr.includes('dashed') || contextStr.includes('dotted'))) {
        return true;
      }

      // Check for arbitrary border radius on outer containers
      if (contextStr.includes('radius') && contextStr.includes('corner') && !token.isActualToken) {
        return true;
      }

      // Check for specific color values that suggest organizational use
      if (contextStr.includes('stroke') || contextStr.includes('border')) {
        // Common wrapper colors: grays, light colors, transparency
        const colorValue = value.toLowerCase();
        if (colorValue.includes('gray') || colorValue.includes('#f0f0f0') || colorValue.includes('#e0e0e0') ||
            colorValue.includes('rgba') || colorValue.includes('transparent')) {
          return true;
        }
      }

      return false;
    }

    // UI State Management
    let currentTab = 'analyze';
    let apiKeySaved = false;
    let currentMetadata = null;
    let currentAuditResults = null;
    let currentTokenSummary = null;
    let batchMode = false;
    let selectedComponents = [];

    // Track the current analysis data for scoring purposes
    let currentAnalysisData = null;

    // Auto-fix state
    let currentNamingIssues = [];
    let currentFixableTokens = [];
    let lastAnalyzedNodeId = null;
    let quickActionsFixCount = 0;
    let namingItemsShown = 15; // Initial limit for naming pagination

    // Chat State Management
    let chatHistory = [];
    let chatSessionId = 'session-' + Date.now();
    let isWaitingForResponse = false;

    // DOM Elements
    const apiKeyInput = document.getElementById('api-key');
    const modelSelect = document.getElementById('model-select');
    const providerSelect = document.getElementById('provider-select');
    const apiKeyLabel = document.getElementById('api-key-label');
    const modelLabel = document.getElementById('model-label');
    const apiKeyHint = document.getElementById('api-key-hint');
    const saveKeyButton = document.getElementById('save-key');
    const analyzeButton = document.getElementById('analyze-component');

    // Provider Configuration
    const providerConfig = {
      anthropic: {
        name: 'Claude',
        placeholder: 'sk-ant-...',
        hint: 'Get your API key from console.anthropic.com',
        defaultModel: 'claude-sonnet-4-5-20250929'
      },
      openai: {
        name: 'OpenAI',
        placeholder: 'sk-...',
        hint: 'Get your API key from platform.openai.com',
        defaultModel: 'gpt-5.2'
      },
      google: {
        name: 'Gemini',
        placeholder: 'AIza...',
        hint: 'Get your API key from aistudio.google.com',
        defaultModel: 'gemini-2.5-pro'
      }
    };

    // Current provider state
    let currentProvider = 'anthropic';
    let providerApiKeys = {}; // Store keys per provider
    const statusContainer = document.getElementById('status-container');
    const statusDiv = document.getElementById('status');
    const statusIcon = document.getElementById('status-icon');
    const statusText = document.getElementById('status-text');
    const clearApiKeyLink = document.getElementById('clear-api-key');

    // Configuration UI Elements
    const apiKeyCard = document.getElementById('api-key-card');
    const quickActions = document.getElementById('quick-actions');
    const quickAnalyzeButton = document.getElementById('quick-analyze-component');
    const showConfigButton = document.getElementById('show-config');
    const hideConfigButton = document.getElementById('hide-config');

    // Batch Mode Elements
    const batchModeToggle = document.getElementById('batch-mode-toggle');
    const batchModeSwitch = document.getElementById('batch-mode-switch');

    // Analysis Results Elements
    const analysisResults = document.getElementById('analysis-results');
    const auditContent = document.getElementById('audit-content');
    const propertyCheatsheet = document.getElementById('property-cheatsheet');
    const tokenSuggestions = document.getElementById('token-suggestions');
    const metadataContent = document.getElementById('metadata-content');
    const auditScore = document.getElementById('audit-score');
    const mcpReadiness = document.getElementById('mcp-readiness');
    const exportMetadataButton = document.getElementById('export-metadata');

    // Playground elements
    const generatePlaygroundButton = document.getElementById('generate-playground');
    const playgroundEmpty = document.getElementById('playground-empty');
    const playgroundContent = document.getElementById('playground-content');
    const playgroundGrid = document.getElementById('playground-grid');

    // Documentation elements
    const exportDocsButton = document.getElementById('export-docs');
    const generateDocsFrameButton = document.getElementById('generate-docs-frame');
    const saveNotesButton = document.getElementById('save-notes');
    const docsEmpty = document.getElementById('docs-empty');
    const docsPreview = document.getElementById('docs-preview');
    const collabNotes = document.getElementById('collab-notes');
    // Note: export-format element is created dynamically, so we get it in the handler function

    // Chat Elements
    const chatEmpty = document.getElementById('chat-empty');
    const chatContainer = document.getElementById('chat-container');
    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const sendChatButton = document.getElementById('send-chat');
    const clearChatButton = document.getElementById('clear-chat');
    const chatStatus = document.getElementById('chat-status');


    // Status Icons
    const statusIcons = {
      info: ICO.info,
      success: ICO.checkCircle,
      error: ICO.xCircle,
      warning: ICO.warnTriangle
    };

    // =============================================
    // Auto-Fix Functionality
    // =============================================

    // Current fix being previewed
    let pendingFix = null;

    // Show the confirmation modal with preview
    function showFixModal(title, previewHtml, fixData) {
      const modal = document.getElementById('fix-modal');
      const modalTitle = document.getElementById('modal-title');
      const modalBody = document.getElementById('modal-body');

      modalTitle.textContent = title;
      modalBody.innerHTML = previewHtml;
      pendingFix = fixData;

      modal.classList.add('active');
    }

    // Hide the confirmation modal
    function hideFixModal() {
      const modal = document.getElementById('fix-modal');
      modal.classList.remove('active');
      pendingFix = null;
    }

    // Confirm and apply the pending fix
    function confirmFix() {
      if (!pendingFix) return;

      const { type, nodeId, propertyPath, newValue, tokenId, fixes } = pendingFix;

      if (type === 'token') {
        sendMessageToPlugin('apply-token-fix', {
          type: 'token',
          nodeId,
          propertyPath,
          tokenId,
          newValue
        });
      } else if (type === 'naming') {
        sendMessageToPlugin('apply-naming-fix', {
          type: 'naming',
          nodeId,
          newValue
        });
      } else if (type === 'description') {
        // Get the textarea value (may have been edited by user)
        const textarea = document.getElementById('description-textarea');
        const description = textarea ? textarea.value : pendingFix.description;
        sendMessageToPlugin('update-description', {
          nodeId: pendingFix.nodeId,
          description
        });
      } else if (type === 'batch') {
        sendMessageToPlugin('apply-batch-fix', {
          fixes: fixes,
          confirmAll: true
        });
      }

      hideFixModal();
      updateStatus('Applying fix...', 'info');
    }

    // Request fix preview for a token
    function previewTokenFix(nodeId, propertyPath, currentValue) {
      // Select the node in Figma so the user can see which element will be updated
      selectFigmaNode(nodeId);
      sendMessageToPlugin('preview-fix', {
        type: 'token',
        nodeId,
        propertyPath,
        suggestedValue: currentValue
      });
    }

    // Batch fix all hard-coded tokens in a section
    function batchFixAllTokens(sectionId) {
      const container = document.getElementById(sectionId);
      if (!container) return;

      const items = container.querySelectorAll('.token-item-compact.warning');
      const fixes = [];

      items.forEach(item => {
        const fixBtn = item.querySelector('.fix-btn');
        if (!fixBtn) return;

        // Extract data from the onclick attribute
        const onclickStr = fixBtn.getAttribute('onclick') || '';
        const match = onclickStr.match(/previewTokenFix\('([^']+)',\s*'([^']+)',\s*'([^']+)'\)/);
        if (match) {
          fixes.push({
            type: 'token',
            nodeId: match[1],
            propertyPath: match[2],
            newValue: match[3]
          });
        }
      });

      if (fixes.length === 0) {
        updateStatus('No fixable items found in this section', 'warning');
        return;
      }

      // Group by value to show a clear preview
      const groups = {};
      fixes.forEach(fix => {
        const key = fix.newValue;
        if (!groups[key]) groups[key] = [];
        groups[key].push(fix);
      });

      let previewHtml = '<div style="margin-bottom: 8px; font-size: 12px;">Apply token fixes to <strong>' + fixes.length + ' item' + (fixes.length !== 1 ? 's' : '') + '</strong>:</div>';
      Object.keys(groups).forEach(value => {
        const count = groups[value].length;
        const prop = groups[value][0].propertyPath;
        previewHtml += '<div class="preview-box" style="margin-bottom: 6px;">';
        previewHtml += '<div class="preview-value">' + escapeHtml(value) + ' (' + prop + ')  ' + count + ' node' + (count !== 1 ? 's' : '') + '</div>';
        previewHtml += '</div>';
      });
      previewHtml += '<p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px;">Each value will be matched to the best available design token.</p>';

      showFixModal('Fix All Tokens', previewHtml, {
        type: 'batch',
        fixes: fixes
      });
    }

    // Toggle a naming tree group open/collapsed
    function toggleNamingGroup(groupId) {
      const items = document.getElementById(groupId);
      const arrow = document.getElementById(groupId + '-arrow');
      if (!items || !arrow) return;
      const isCollapsed = items.classList.contains('collapsed');
      if (isCollapsed) {
        items.classList.remove('collapsed');
        items.style.maxHeight = items.scrollHeight + 'px';
        arrow.classList.remove('collapsed');
      } else {
        items.classList.add('collapsed');
        items.style.maxHeight = '0';
        arrow.classList.add('collapsed');
      }
    }

    // Toggle all naming tree groups
    function toggleAllNamingGroups() {
      const allGroups = document.querySelectorAll('.naming-tree-items');
      const allArrows = document.querySelectorAll('.naming-tree-group-header .tree-arrow');
      const btn = document.querySelector('.naming-tree-toggle');
      const anyCollapsed = Array.from(allGroups).some(g => g.classList.contains('collapsed'));

      allGroups.forEach(group => {
        if (anyCollapsed) {
          group.classList.remove('collapsed');
          group.style.maxHeight = group.scrollHeight + 'px';
        } else {
          group.classList.add('collapsed');
          group.style.maxHeight = '0';
        }
      });
      allArrows.forEach(arrow => {
        if (anyCollapsed) {
          arrow.classList.remove('collapsed');
        } else {
          arrow.classList.add('collapsed');
        }
      });
      if (btn) {
        btn.textContent = anyCollapsed ? 'Collapse All' : 'Expand All';
      }
    }

    // Show more naming issues (paginated)
    function showMoreNamingIssues() {
      if (!currentNamingIssues || currentNamingIssues.length === 0) return;

      const container = document.getElementById('naming-scroll-container');
      const showMoreContainer = document.getElementById('naming-show-more-container');
      if (!container) return;

      // Group all issues by path (same logic as initial render)
      const grouped = {};
      currentNamingIssues.forEach(issue => {
        const pathParts = issue.path ? issue.path.split(' > ') : ['Root'];
        const parentPath = pathParts.length > 1 ? pathParts.slice(0, -1).join(' > ') : 'Root';
        if (!grouped[parentPath]) grouped[parentPath] = [];
        grouped[parentPath].push(issue);
      });
      const groupKeys = Object.keys(grouped);

      // Flatten for pagination
      const allFlatItems = [];
      groupKeys.forEach(groupPath => {
        grouped[groupPath].forEach(issue => {
          allFlatItems.push({ groupPath, issue });
        });
      });

      const prevShown = namingItemsShown;
      namingItemsShown = Math.min(allFlatItems.length, namingItemsShown + 20);

      // Render new items
      let html = '';
      let currentGroup = null;

      // Check what the last group was in the container
      const existingGroups = container.querySelectorAll('.naming-tree-group');
      let lastExistingGroup = null;
      if (existingGroups.length > 0) {
        const lastHeader = existingGroups[existingGroups.length - 1].querySelector('.naming-tree-group-header span:nth-child(2)');
        if (lastHeader) lastExistingGroup = lastHeader.textContent;
      }

      for (let i = prevShown; i < namingItemsShown; i++) {
        const entry = allFlatItems[i];
        const issue = entry.issue;

        if (entry.groupPath !== currentGroup) {
          // Check if this group already exists from previous items
          if (entry.groupPath === lastExistingGroup && currentGroup === null) {
            // Append to existing group
            const lastGroupItems = existingGroups[existingGroups.length - 1].querySelector('.naming-tree-items');
            if (lastGroupItems) {
              // We'll append directly to the existing group's items div
              const severityIcon = issue.severity === 'error' ? ICO.xCircle : issue.severity === 'warning' ? ICO.warnTriangle : ICO.info;
              const severityClass = issue.severity === 'error' ? 'fail' : issue.severity === 'warning' ? 'warning' : 'info';
              const escapedCurrent = issue.currentName.replace(/'/g, "\\'").replace(/"/g, '&quot;');
              const escapedSuggested = issue.suggestedName.replace(/'/g, "\\'").replace(/"/g, '&quot;');

              const itemEl = document.createElement('div');
              itemEl.className = 'naming-tree-item';
              itemEl.setAttribute('data-node-id', issue.nodeId);
              itemEl.setAttribute('onclick', `if(event.target.tagName!=='BUTTON')selectFigmaNode('${issue.nodeId}')`);
              itemEl.title = 'Click to select this layer in Figma';
              itemEl.innerHTML = `
                <span class="audit-status ${severityClass}">${severityIcon}</span>
                <div class="audit-content">
                  <span class="audit-label">
                    <code style="font-size: 10px; background: var(--surface); padding: 1px 4px; border-radius: 2px;">${escapeHtml(issue.currentName)}</code>
                    <span class="naming-issue-arrow">&rarr;</span>
                    <code style="font-size: 10px; background: var(--surface); padding: 1px 4px; border-radius: 2px;">${escapeHtml(issue.suggestedName)}</code>
                  </span>
                  <div style="font-size: 10px; color: var(--text-tertiary); margin-top: 2px;">${issue.reason}</div>
                </div>
                <button class="audit-action-button" data-node-id="${issue.nodeId}" onclick="event.stopPropagation();previewNamingFix('${issue.nodeId}', '${escapedCurrent}', '${escapedSuggested}')" title="Rename this layer">Rename</button>
              `;
              lastGroupItems.appendChild(itemEl);
              lastGroupItems.style.maxHeight = lastGroupItems.scrollHeight + 'px';
              currentGroup = entry.groupPath;
              continue;
            }
          }

          if (currentGroup !== null) html += '</div></div>';
          currentGroup = entry.groupPath;
          const groupId = 'naming-group-' + groupKeys.indexOf(entry.groupPath);
          html += `<div class="naming-tree-group">`;
          html += `<div class="naming-tree-group-header" onclick="toggleNamingGroup('${groupId}')">
            <span class="tree-arrow" id="${groupId}-arrow"></span>
            <span>${escapeHtml(entry.groupPath)}</span>
            <span class="group-count">${grouped[entry.groupPath].length}</span>
          </div>`;
          html += `<div class="naming-tree-items" id="${groupId}" style="max-height: ${grouped[entry.groupPath].length * 60}px;">`;
        }

        const severityIcon = issue.severity === 'error' ? ICO.xCircle : issue.severity === 'warning' ? ICO.warnTriangle : ICO.info;
        const severityClass = issue.severity === 'error' ? 'fail' : issue.severity === 'warning' ? 'warning' : 'info';
        const escapedCurrent = issue.currentName.replace(/'/g, "\\'").replace(/"/g, '&quot;');
        const escapedSuggested = issue.suggestedName.replace(/'/g, "\\'").replace(/"/g, '&quot;');

        html += `
          <div class="naming-tree-item" data-node-id="${issue.nodeId}" onclick="if(event.target.tagName!=='BUTTON')selectFigmaNode('${issue.nodeId}')" title="Click to select this layer in Figma">
            <span class="audit-status ${severityClass}">${severityIcon}</span>
            <div class="audit-content">
              <span class="audit-label">
                <code style="font-size: 10px; background: var(--surface); padding: 1px 4px; border-radius: 2px;">${escapeHtml(issue.currentName)}</code>
                <span class="naming-issue-arrow">&rarr;</span>
                <code style="font-size: 10px; background: var(--surface); padding: 1px 4px; border-radius: 2px;">${escapeHtml(issue.suggestedName)}</code>
              </span>
              <div style="font-size: 10px; color: var(--text-tertiary); margin-top: 2px;">${issue.reason}</div>
            </div>
            <button class="audit-action-button" data-node-id="${issue.nodeId}" onclick="event.stopPropagation();previewNamingFix('${issue.nodeId}', '${escapedCurrent}', '${escapedSuggested}')" title="Rename this layer">Rename</button>
          </div>
        `;
      }

      if (currentGroup !== null) html += '</div></div>';

      // Append new groups to the scroll container
      if (html) {
        container.insertAdjacentHTML('beforeend', html);
      }

      // Update or remove "Show More" button
      const remaining = allFlatItems.length - namingItemsShown;
      if (remaining > 0 && showMoreContainer) {
        const btn = document.getElementById('naming-show-more-btn');
        if (btn) {
          btn.textContent = `Show More (${Math.min(20, remaining)} of ${remaining} remaining)`;
        }
      } else if (showMoreContainer) {
        showMoreContainer.remove();
      }
    }

    // Request fix preview for naming
    function previewNamingFix(nodeId, currentName, suggestedName) {
      // Select the node in Figma so the user can see which layer will be renamed
      selectFigmaNode(nodeId);
      // Show preview directly since we have the info
      const previewHtml = `
        <div class="preview-box">
          <div class="preview-label">Current Name</div>
          <div class="preview-value">${escapeHtml(currentName)}</div>
        </div>
        <div class="preview-arrow"></div>
        <div class="preview-box">
          <div class="preview-label">New Name</div>
          <div class="preview-value">${escapeHtml(suggestedName)}</div>
        </div>
      `;

      showFixModal('Rename Layer', previewHtml, {
        type: 'naming',
        nodeId,
        newValue: suggestedName
      });
    }


    // Helper to escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Initialize UI
    function initializeUI() {
      console.log('Initializing enhanced UI...');

      // Event Listeners
      saveKeyButton.addEventListener('click', handleSaveApiKey);
      analyzeButton.addEventListener('click', handleAnalyzeComponent);
      quickAnalyzeButton.addEventListener('click', handleAnalyzeComponent);
      apiKeyInput.addEventListener('input', handleApiKeyChange);
      apiKeyInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && apiKeyInput.value.trim()) {
          handleSaveApiKey();
        }
      });

      // Provider selection handling
      if (providerSelect) {
        providerSelect.addEventListener('change', handleProviderChange);
      }

      // Model selection handling
      modelSelect.addEventListener('change', handleModelChange);

      clearApiKeyLink.addEventListener('click', handleClearApiKey);
      batchModeSwitch.addEventListener('change', handleBatchModeToggle);

      // Configuration visibility toggles
      showConfigButton.addEventListener('click', () => {
        apiKeyCard.style.display = 'block';
        quickActions.style.display = 'none';
      });

      hideConfigButton.addEventListener('click', () => {
        if (apiKeySaved) {
          apiKeyCard.style.display = 'none';
          quickActions.style.display = 'flex';
        }
      });

      // Export functionality
      if (exportMetadataButton) {
        exportMetadataButton.addEventListener('click', handleExportMetadata);
      }

      // Playground and documentation buttons (with null checks)
      if (generatePlaygroundButton) {
        generatePlaygroundButton.addEventListener('click', handleGeneratePlayground);
      }
      if (exportDocsButton) {
        exportDocsButton.addEventListener('click', handleExportDocs);
      }
      if (generateDocsFrameButton) {
        generateDocsFrameButton.addEventListener('click', handleGenerateDocsFrame);
      }
      if (saveNotesButton) {
        saveNotesButton.addEventListener('click', handleSaveNotes);
      }

      // Chat Event Listeners
      if (sendChatButton) {
        sendChatButton.addEventListener('click', handleSendChat);
      }
      if (clearChatButton) {
        clearChatButton.addEventListener('click', handleClearChat);
      }
      if (chatInput) {
        chatInput.addEventListener('keydown', handleChatKeydown);
        chatInput.addEventListener('input', handleChatInputChange);
      }

      // Listen for messages from plugin
      window.addEventListener('message', handlePluginMessage);

      // Request current API key status
      sendMessageToPlugin('check-api-key', {});
    }

    // Handle Export Metadata
    function handleExportMetadata() {
      if (!currentMetadata) {
        updateStatus('No analysis results available', 'error');
        return;
      }

      const exportFormatSelect = document.getElementById('export-format');
      if (!exportFormatSelect) {
        updateStatus('Export format not selected', 'error');
        return;
      }

      const format = exportFormatSelect.value;
      let content = '';

      if (format === 'json') {
        content = JSON.stringify(currentMetadata, null, 2);
      } else if (format === 'markdown') {
        content = generateMarkdownDocumentation(currentMetadata);
      }

      if (content) {
        // Download file
        const blob = new Blob([content], { type: format === 'json' ? 'application/json' : 'text/markdown' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${currentMetadata.component || 'component'}-${format.toLowerCase()}.${format === 'json' ? 'json' : 'md'}`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        updateStatus(`${format.toUpperCase()} exported successfully!`, 'success');
      } else {
        updateStatus('No content to export', 'error');
      }
    }

    // Generate Markdown Documentation
    function generateMarkdownDocumentation(metadata) {
      let content = `# ${metadata.component}\n\n`;
      content += `${metadata.description}\n\n`;

      if (metadata.usage) {
        content += `## Usage\n\n${metadata.usage}\n\n`;
      }

      if (metadata.props && metadata.props.length > 0) {
        content += `## Properties\n\n`;
        content += `| Property | Type | Default | Required | Description |\n`;
        content += `|----------|------|---------|----------|-------------|\n`;
        metadata.props.forEach(prop => {
          content += `| ${prop.name} | \`${prop.type}\` | \`${prop.defaultValue}\` | ${prop.required ? 'Yes' : 'No'} | ${prop.description} |\n`;
        });
        content += `\n`;
      }

      if (metadata.states && metadata.states.length > 0) {
        content += `## States\n\n`;
        metadata.states.forEach(state => {
          content += `- \`${state}\`\n`;
        });
        content += `\n`;
      }

      if (metadata.mcpReadiness) {
        content += `## AI Interpretation\n\n`;
        if (metadata.mcpReadiness.strengths && metadata.mcpReadiness.strengths.length > 0) {
          content += `**What AI Reads Well:**\n`;
          metadata.mcpReadiness.strengths.forEach(s => { content += `- ${s}\n`; });
          content += `\n`;
        }
        if (metadata.mcpReadiness.gaps && metadata.mcpReadiness.gaps.length > 0) {
          content += `**Where AI Gets Confused:**\n`;
          metadata.mcpReadiness.gaps.forEach(g => { content += `- ${g}\n`; });
          content += `\n`;
        }
        if (metadata.mcpReadiness.recommendations && metadata.mcpReadiness.recommendations.length > 0) {
          content += `**How to Improve AI Understanding:**\n`;
          metadata.mcpReadiness.recommendations.forEach(rec => { content += `- ${rec}\n`; });
          content += `\n`;
        }
        if (metadata.mcpReadiness.implementationNotes) {
          content += `**What AI Would Generate:**\n${metadata.mcpReadiness.implementationNotes}\n\n`;
        }
      }

      return content;
    }

    // Tab Switching
    function switchTab(tabName) {
      // Update active tab button
      document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('active');
      });
      document.getElementById(`tab-${tabName}`).classList.add('active');

      // Update active tab content
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      document.getElementById(`content-${tabName}`).classList.add('active');

      currentTab = tabName;

      // Update tab-specific UI
      if (tabName === 'chat') {
        updateChatInputState();
        updateChatComponentContext();
      }
    }

    // Collapsible Sections
    function toggleCollapsible(header) {
      header.classList.toggle('active');
      const content = header.nextElementSibling;
      content.classList.toggle('active');
    }

    // JS-based viewport-aware tooltip system
    (function initTooltipSystem() {
      let activeTooltip = null;

      document.addEventListener('mouseover', function(e) {
        const trigger = e.target.closest('.tooltip');
        if (!trigger) return;

        const textEl = trigger.querySelector('.tooltiptext');
        if (!textEl) return;

        // Remove any existing tooltip
        if (activeTooltip) {
          activeTooltip.remove();
          activeTooltip = null;
        }

        const popup = document.createElement('div');
        popup.className = 'tooltip-popup';
        popup.innerHTML = textEl.innerHTML;
        document.body.appendChild(popup);
        activeTooltip = popup;

        const rect = trigger.getBoundingClientRect();
        const popupRect = popup.getBoundingClientRect();
        const margin = 4;

        // Try above first
        let top = rect.top - popupRect.height - 8;
        if (top < margin) {
          // Flip below
          top = rect.bottom + 8;
          popup.classList.add('tooltip-below');
        } else {
          popup.classList.add('tooltip-above');
        }

        // Clamp horizontal position within viewport
        let left = rect.left + rect.width / 2 - popupRect.width / 2;
        left = Math.max(margin, Math.min(left, window.innerWidth - popupRect.width - margin));

        popup.style.top = top + 'px';
        popup.style.left = left + 'px';
      });

      document.addEventListener('mouseout', function(e) {
        const trigger = e.target.closest('.tooltip');
        if (!trigger) return;

        if (activeTooltip) {
          activeTooltip.remove();
          activeTooltip = null;
        }
      });
    })();

    // Handle API Key Changes
    function handleApiKeyChange() {
      const hasApiKey = apiKeyInput.value.trim().length > 0;
      if (hasApiKey && apiKeySaved) {
        updateAnalyzeButtonState(true);
      }
    }

    // Handle Provider Change
    function handleProviderChange() {
      const selectedProvider = providerSelect.value;
      const config = providerConfig[selectedProvider];

      if (!config) return;

      // Store current provider's API key before switching
      if (apiKeyInput.value.trim()) {
        providerApiKeys[currentProvider] = apiKeyInput.value.trim();
      }

      // Update current provider
      currentProvider = selectedProvider;

      // Update UI labels
      if (apiKeyLabel) apiKeyLabel.textContent = config.name;
      if (modelLabel) modelLabel.textContent = config.name;
      if (apiKeyHint) apiKeyHint.textContent = config.hint;
      apiKeyInput.placeholder = config.placeholder;

      // Restore saved API key for this provider (if any)
      apiKeyInput.value = providerApiKeys[selectedProvider] || '';

      // Update model dropdown  disable options not belonging to selected provider
      const providerGroups = {
        anthropic: document.getElementById('anthropic-models'),
        openai: document.getElementById('openai-models'),
        google: document.getElementById('google-models')
      };

      Object.entries(providerGroups).forEach(([key, group]) => {
        if (!group) return;
        const isActive = key === selectedProvider;
        group.style.display = isActive ? '' : 'none';
        // Disable hidden options so they can't be selected
        Array.from(group.querySelectorAll('option')).forEach(opt => {
          opt.disabled = !isActive;
        });
      });

      // Select default model for this provider
      modelSelect.value = config.defaultModel;

      // Update button state based on whether we have a key for this provider
      const hasKey = apiKeyInput.value.trim().length > 0;
      updateAnalyzeButtonState(hasKey && apiKeySaved);

      console.log('Provider changed to:', selectedProvider, 'Model:', config.defaultModel);
    }

    // Handle Save API Key
    function handleSaveApiKey() {
      const apiKey = apiKeyInput.value.trim();
      const selectedModel = modelSelect.value;
      const selectedProvider = providerSelect ? providerSelect.value : 'anthropic';

      if (!apiKey) {
        updateStatus('Please enter an API key', 'error');
        return;
      }

      // Store key for this provider
      providerApiKeys[selectedProvider] = apiKey;

      saveKeyButton.disabled = true;
      updateStatus(`Saving ${providerConfig[selectedProvider]?.name || 'API'} key...`, 'info');
      sendMessageToPlugin('save-api-key', {
        apiKey,
        model: selectedModel,
        provider: selectedProvider
      });
    }

    // Handle Model Change
    function handleModelChange() {
      const selectedModel = modelSelect.value;
      console.log('Model changed to:', selectedModel);

      // If API key is saved, update the model immediately
      if (apiKeySaved) {
        sendMessageToPlugin('update-model', { model: selectedModel });
        // Get the display name from the selected option text
        const selectedOption = modelSelect.options[modelSelect.selectedIndex];
        const displayName = selectedOption ? selectedOption.textContent.trim() : selectedModel;
        updateStatus(`Model updated to ${displayName}`, 'success');
      }
    }

    // Handle Analyze Component
    function handleAnalyzeComponent() {
      if (!apiKeySaved) {
        updateStatus('Please save API key first', 'error');
        return;
      }

      analyzeButton.disabled = true;
      updateStatus('Analyzing selected component...', 'info');

      // Reset scores immediately to avoid showing stale data
      auditScore.innerHTML = '<span>Score: --</span>';
      auditScore.className = 'status-banner status-info';

      // Show analysis results with loading state
      analysisResults.classList.remove('hidden');
      showLoadingState();

      sendMessageToPlugin('analyze-enhanced', {
        batchMode: batchMode,
        includeAudit: true,
        includeTokens: true,
        includeValidation: true
      });
    }

    // Handle Clear API Key
    function handleClearApiKey(e) {
      e.preventDefault();
      if (confirm('Are you sure you want to clear the saved API key?')) {
        sendMessageToPlugin('clear-api-key', {});
        apiKeyInput.value = '';
        apiKeyInput.placeholder = 'sk-ant-...';
        clearApiKeyLink.classList.add('hidden');
        apiKeySaved = false;
        updateAnalyzeButtonState(false);
        updateStatus('API key cleared', 'info');

        // Show config and hide quick actions
        apiKeyCard.style.display = 'block';
        quickActions.style.display = 'none';
      }
    }

    // Handle Batch Mode Toggle
    function handleBatchModeToggle() {
      batchMode = batchModeSwitch.checked;
      updateStatus(batchMode ? 'Batch mode enabled' : 'Batch mode disabled', 'info');
    }

    // Handle Generate Playground
    function handleGeneratePlayground() {
      if (!currentMetadata) {
        updateStatus('No analysis results available', 'error');
        return;
      }

      if (generatePlaygroundButton) {
        generatePlaygroundButton.disabled = true;
      }
      updateStatus('Generating playground instances...', 'info');
      sendMessageToPlugin('generate-playground', { metadata: currentMetadata });
    }

    // Handle Export Documentation
    function handleExportDocs() {
      if (!currentMetadata) {
        updateStatus('No analysis results available', 'error');
        return;
      }

      const format = exportFormat.value;
      if (format === 'markdown') {
        exportAsMarkdown();
      } else if (format === 'json') {
        exportAsJSON();
      }
    }

    // Handle Generate Docs Frame
    function handleGenerateDocsFrame() {
      if (!currentMetadata) {
        updateStatus('No analysis results available', 'error');
        return;
      }

      if (generateDocsFrameButton) {
        generateDocsFrameButton.disabled = true;
      }
      updateStatus('Generating documentation frame...', 'info');
      sendMessageToPlugin('generate-docs-frame', {
        metadata: currentMetadata,
        notes: collabNotes && collabNotes.value ? collabNotes.value : ''
      });
    }

    // Handle Save Notes
    function handleSaveNotes() {
      const notes = collabNotes.value.trim();
      if (!notes) {
        updateStatus('Please enter some notes', 'warning');
        return;
      }

      sendMessageToPlugin('save-collab-notes', { notes });
      updateStatus('Notes saved', 'success');
    }

    // Handle Plugin Messages
    function handlePluginMessage(event) {
      const { type, data } = event.data.pluginMessage || {};

      switch (type) {
        case 'api-key-saved':
          handleApiKeySaved(data.success, data.provider);
          break;
        case 'api-key-status':
          handleApiKeyStatus(data.hasKey, data.provider, data.model);
          break;
        case 'enhanced-analysis-result':
          handleEnhancedAnalysisResult(data);
          break;
        case 'metadata-result':
          // Handle old message format for backward compatibility
          handleEnhancedAnalysisResult({
            metadata: data.metadata,
            audit: null,
            properties: [],
            tokens: {}
          });
          break;
        case 'analysis-complete':
          // Handle old message format - do nothing as the data is already displayed
          if (data.success) {
            console.log('Analysis completed:', data.message);
          }
          break;
        case 'playground-generated':
          handlePlaygroundGenerated(data);
          break;
        case 'docs-frame-generated':
          handleDocsFrameGenerated(data);
          break;
        case 'batch-selection-update':
          handleBatchSelectionUpdate(data);
          break;
        case 'analysis-error':
          handleAnalysisError(data.error);
          break;
        case 'variants-generated':
          handlePlaygroundGenerated(data);
          break;
        case 'docs-generated':
          handleDocsFrameGenerated(data);
          break;
        case 'notes-saved':
          if (data.success) {
            updateStatus('Notes saved with visual indicator!', 'success');
          } else {
            updateStatus(`Failed to save notes: ${data.error}`, 'error');
          }
          break;
        case 'state-added':
          if (data.success) {
            updateStatus(`${data.state} state added successfully!`, 'success');
          } else {
            updateStatus(`Failed to add state: ${data.error}`, 'error');
          }
          break;
        case 'accessibility-fixed':
          if (data.success) {
            updateStatus(`Accessibility issue fixed!`, 'success');
          } else {
            updateStatus(`Failed to fix accessibility: ${data.error}`, 'error');
          }
          break;
        case 'naming-fixed':
          if (data.success) {
            updateStatus(`Layer renamed successfully!`, 'success');
          } else {
            updateStatus(`Failed to rename layer: ${data.error}`, 'error');
          }
          break;
        case 'chat-response':
          handleChatResponse(data.response);
          break;
        case 'chat-response-loading':
          handleChatLoading(data.isLoading);
          break;
        case 'chat-error':
          handleChatError(data.error);
          break;
        case 'chat-history-cleared':
          handleChatHistoryCleared();
          break;
        case 'fix-preview':
          handleFixPreview(data);
          break;
        case 'fix-applied':
          handleFixApplied(data);
          break;
        case 'batch-fix-applied':
          handleBatchFixApplied(data);
          break;
        case 'description-updated':
          handleDescriptionUpdated(data);
          break;
        default:
          console.log('Unknown message type:', type);
      }
    }

    // Handle API Key Saved
    function handleApiKeySaved(success, provider) {
      saveKeyButton.disabled = false;
      if (success) {
        // Ensure UI provider state matches what was saved
        if (provider && providerSelect && providerSelect.value !== provider) {
          providerSelect.value = provider;
          handleProviderChange();
        }
        apiKeySaved = true;
        updateStatus('API key saved successfully!', 'success');
        updateAnalyzeButtonState(true);
        clearApiKeyLink.classList.remove('hidden');
        apiKeyInput.value = '';
        apiKeyInput.placeholder = 'API key saved ';

        // Show quick actions and hide config
        apiKeyCard.style.display = 'none';
        quickActions.style.display = 'flex';
        hideConfigButton.style.display = 'inline-flex';

        // Update chat input state
        updateChatInputState();
      } else {
        updateStatus('Failed to save API key', 'error');
      }
    }

    // Handle API Key Status
    function handleApiKeyStatus(hasKey, provider, model) {
      apiKeySaved = hasKey;

      // Restore saved provider and model selections
      if (provider && providerSelect) {
        providerSelect.value = provider;
        // Trigger provider change to update labels, model visibility, etc.
        handleProviderChange();
      }
      if (model && modelSelect) {
        modelSelect.value = model;
      }

      if (hasKey) {
        updateStatus('API key is configured', 'success');
        updateAnalyzeButtonState(true);
        clearApiKeyLink.classList.remove('hidden');
        apiKeyInput.placeholder = 'API key saved ';

        // Show quick actions and hide config
        apiKeyCard.style.display = 'none';
        quickActions.style.display = 'flex';
        hideConfigButton.style.display = 'inline-flex';

        // Enable chat tab
        const chatTabButton = document.getElementById('tab-chat');
        if (chatTabButton) {
          chatTabButton.disabled = false;
        }
      } else {
        updateStatus('Enter API key to get started', 'info');
        updateAnalyzeButtonState(false);
        clearApiKeyLink.classList.add('hidden');

        // Show config and hide quick actions
        apiKeyCard.style.display = 'block';
        quickActions.style.display = 'none';

        // Disable chat tab and switch back to analyze if currently on chat
        const chatTabButton = document.getElementById('tab-chat');
        if (chatTabButton) {
          chatTabButton.disabled = true;
          if (currentTab === 'chat') {
            switchTab('analyze');
          }
        }
      }

      // Update chat input state
      updateChatInputState();
    }

    // Handle Enhanced Analysis Result
    function handleEnhancedAnalysisResult(data) {
      // Debug logging
      console.log('UI received enhanced analysis result:', data);
      console.log('Audit data received in UI:', data.audit);
      console.log('Token summary received in UI:', data.tokens ? data.tokens.summary : undefined);

      // Store analysis data globally for scoring
      currentAnalysisData = data;
      window.currentAnalysisData = data;

      analyzeButton.disabled = false;
      quickAnalyzeButton.disabled = false;
      currentMetadata = data.metadata;
      currentAuditResults = data.audit;
      currentTokenSummary = data.tokens ? data.tokens.summary : undefined;

      // Store naming issues and fixable tokens for auto-fix
      currentNamingIssues = data.namingIssues || [];
      namingItemsShown = 15; // Reset pagination on new analysis
      currentFixableTokens = [];
      if (data.tokens) {
        ['colors', 'spacing', 'typography', 'effects', 'borders'].forEach(cat => {
          if (data.tokens[cat] && Array.isArray(data.tokens[cat])) {
            data.tokens[cat].forEach(token => {
              if (!token.isActualToken && token.source === 'hard-coded' && !token.isDefaultVariantStyle && token.context && token.context.nodeId) {
                currentFixableTokens.push(token);
              }
            });
          }
        });
      }

      // Store the analyzed node ID for description updates
      lastAnalyzedNodeId = data.analyzedNodeId || null;
      if (!lastAnalyzedNodeId) {
        // Fallback: extract from token context or naming issues
        if (currentFixableTokens.length > 0 && currentFixableTokens[0].context) {
          lastAnalyzedNodeId = currentFixableTokens[0].context.nodeId;
        } else if (currentNamingIssues.length > 0) {
          lastAnalyzedNodeId = currentNamingIssues[0].nodeId;
        }
      }

      // Update Audit View
      if (data.audit) {
        updateAuditView(data.audit);
      } else {
        // Show realistic audit with actual issues instead of fake passing scores
        const basicAudit = {
          states: [
            { name: 'default', found: true },
            { name: 'hover', found: false },
            { name: 'focus', found: false },
            { name: 'disabled', found: false },
            { name: 'pressed', found: false },
            { name: 'active', found: false }
          ],
          accessibility: [
            { check: 'Focus indicator', status: 'fail', suggestion: 'Add focus indicator for keyboard navigation' },
            { check: 'ARIA labels', status: 'warning', suggestion: 'Consider adding ARIA labels for screen readers' }
          ],
          naming: []
        };
        console.log('Using fallback basic audit with real issues:', basicAudit);
        updateAuditView(basicAudit);
      }

      // Update Property Cheat Sheet
      if (data.properties && data.properties.length > 0) {
        console.log('UI: Using data.properties:', data.properties);
        updatePropertyCheatSheet(data.properties, data.recommendations);
      } else if (data.metadata && data.metadata.propertyCheatSheet && data.metadata.propertyCheatSheet.length > 0) {
        console.log('UI: Using data.metadata.propertyCheatSheet:', data.metadata.propertyCheatSheet);
        updatePropertyCheatSheet(data.metadata.propertyCheatSheet, data.recommendations);
      } else if (data.metadata && data.metadata.props && data.metadata.props.length > 0) {
        console.log('UI: Falling back to data.metadata.props:', data.metadata.props);
        // Create basic properties from metadata props
        const basicProperties = data.metadata.props.map(prop => {
          // Handle both object format and string format
          if (typeof prop === 'string') {
            return {
              name: prop,
              values: ['true', 'false'],
              default: 'false'
            };
          } else if (typeof prop === 'object' && prop !== null) {
            return {
              name: prop.name || 'Unknown',
              values: prop.values || ['true', 'false'],
              default: prop.default || prop.defaultValue || 'false'
            };
          } else {
            return {
              name: String(prop),
              values: ['true', 'false'],
              default: 'false'
            };
          }
        });
        updatePropertyCheatSheet(basicProperties, data.recommendations);
      } else {
        console.log('UI: No properties found, checking for recommendations only');
        updatePropertyCheatSheet([], data.recommendations);
      }

      // Update Token Analysis
      if (data.tokens && Object.keys(data.tokens).length > 0) {
        updateTokenSuggestions(data.tokens);
      } else {
        // Show empty state for tokens
        tokenSuggestions.innerHTML = '<p style="color: var(--text-tertiary); text-align: center;">No design tokens detected</p>';
      }

      // Update MCP Readiness
      if (data.metadata && data.metadata.mcpReadiness) {
        updateMCPReadiness(data.metadata.mcpReadiness);
      } else {
        mcpReadiness.innerHTML = '<p style="color: var(--text-tertiary); text-align: center; padding: 20px;">AI interpretation analysis not available</p>';
      }

      // Update Developer Export Section
      updateDeveloperExport(data.metadata);

      // Update Original Metadata
      if (data.metadata) {
        updateMetadataDisplay(data.metadata);
      }

      // Enable relevant buttons
      updateUIButtonStates();

      // Render Quick Actions bar (Phase 2)
      const analysisResults = document.getElementById('analysis-results');
      const existingBar = document.getElementById('fix-summary-bar');
      if (existingBar) existingBar.remove();

      const fixCounts = computeFixableCounts(data);
      if (fixCounts.total > 0 && analysisResults) {
        const barHtml = renderQuickActionsBar(fixCounts);
        analysisResults.insertAdjacentHTML('afterbegin', barHtml);
      }

      // Update chat component context if we're on chat tab or switching to it
      updateChatComponentContext();

      updateStatus('Analysis complete!', 'success');
    }

    // Update Audit View
    function updateAuditView(audit) {
      let html = '';
      let passCount = 0;
      let totalCount = 0;
      let weightedPassScore = 0;
      let weightedTotalScore = 0;

      // Backward compatibility: if no componentReadiness, migrate old accessibility checks
      if (!audit.componentReadiness && audit.accessibility) {
        const readinessChecks = ['Property configuration', 'Component description'];
        audit.componentReadiness = audit.accessibility.filter(item => readinessChecks.includes(item.check));
        audit.accessibility = audit.accessibility.filter(item => !readinessChecks.includes(item.check));
      }

      // START WITH BASELINE POSITIVE SCORING - Award points for good practices
      console.log('[DEBUG][SCORING] Starting with baseline positive scoring...');

      // Baseline points for just having a component (5 points)
      // REMOVED: Unconditional bonus was allowing 100% scores despite warnings
      // Components must now earn their score through actual quality checks
      console.log('[DEBUG][SCORING] Baseline bonuses removed to make warnings count');

      // Token and property bonuses removed to prevent grade inflation
      // Score is now based purely on audit checks passing
      // This ensures warnings properly reduce the score below 100%

      // DESIGN TOKEN USAGE SCORING - High impact on overall score
      let tokenPassCount = 0;
      let tokenTotalCount = 0;
      console.log(`[DEBUG][TOKEN SCORING START] currentTokenSummary exists: ${!!currentTokenSummary}, totalTokens: ${currentTokenSummary ? currentTokenSummary.totalTokens : 'undefined'}`);

      if (currentTokenSummary && currentTokenSummary.totalTokens > 0) {
        console.log(`[DEBUG][TOKEN SCORING] Entering token scoring block...`);
        // Filter out likely wrapper/boundary elements from scoring
        const filteredHardCoded = filterWrapperElements(currentTokenSummary);
        const scorableHardCoded = filteredHardCoded.hardCodedValues;
        const scorableTotal = filteredHardCoded.totalTokens;

        console.log(`[DEBUG][TOKEN SCORING] Original: ${currentTokenSummary.hardCodedValues} hard-coded, ${currentTokenSummary.totalTokens} total`);
        console.log(`[DEBUG][TOKEN SCORING] After filtering: ${scorableHardCoded} hard-coded, ${scorableTotal} total`);

        if (scorableTotal > 0) {
          console.log(`[DEBUG][TOKEN SCORING] scorableTotal > 0, proceeding with scoring...`);
          // Each token-able property gets weighted scoring (2x weight - important for design systems)
          tokenTotalCount = scorableTotal;
          // IMPORTANT: Use scorable tokens for both numerator and denominator
          // We can't give credit for filtered-out wrapper tokens
          const scorableActualTokens = Math.min(currentTokenSummary.actualTokens, scorableTotal);
          tokenPassCount = scorableActualTokens;

          const tokenWeight = 2; // High importance for design system compliance
          weightedTotalScore += tokenTotalCount * tokenWeight;
          weightedPassScore += tokenPassCount * tokenWeight;

          console.log(`[DEBUG][TOKEN SCORING] Added ${tokenTotalCount * tokenWeight} total token points, ${tokenPassCount * tokenWeight} passing token points`);
          console.log(`[DEBUG][TOKEN SCORING] Running totals: ${weightedPassScore} / ${weightedTotalScore}`);
        } else {
          console.log(`[DEBUG][TOKEN SCORING] scorableTotal is 0 or negative, skipping token scoring`);
        }
      } else {
        console.log(`[DEBUG][TOKEN SCORING] Skipped - no currentTokenSummary or totalTokens is 0`);
      }

      // States Audit
      if (audit.states && audit.states.length > 0) {
        html += '<div class="audit-section">';
        html += `
          <div class="section-header">
            <h4 class="section-title">Interactive States</h4>
            <div class="tooltip">
              <div class="info-icon">i</div>
              <span class="tooltiptext">
                <strong>Interactive States</strong><br>
                Components that users can interact with (buttons, inputs, links) need different visual states to provide feedback. This includes hover (when cursor is over), focus (when selected via keyboard), active (when being clicked), and disabled states. Missing states can confuse users and hurt accessibility.
              </span>
            </div>
          </div>
        `;

        // Check if this is a non-interactive component (like badge) with only default state
        const hasOnlyDefaultState = audit.states.length === 1 &&
          audit.states[0].name === 'default' &&
          audit.states[0].found === true;

        if (hasOnlyDefaultState) {
          // Show positive message for non-interactive components
          html += `
            <div class="audit-item">
              <span class="audit-status pass">${ICO.checkCircle}</span>
              <span class="audit-label">No interactive states needed for this component</span>
            </div>
          `;
          totalCount++;
          passCount++;
          // High weight for states (3x) - critical for MCP compatibility
          weightedTotalScore += 3;
          weightedPassScore += 3;
        } else {
          // Show standard state audit for interactive components
          audit.states.forEach(state => {
            totalCount++;
            const status = state.found ? 'pass' : 'fail';
            if (state.found) passCount++;

            // High weight for states (3x) - critical for MCP compatibility
            weightedTotalScore += 3;
            if (state.found) {
              weightedPassScore += 3;
              console.log(`[DEBUG][STATES] "${state.name}" = PASS  +3 points`);
            } else {
              console.log(`[DEBUG][STATES] "${state.name}" = FAIL  0 points`);
            }

            html += `
              <div class="audit-item">
                ${state.found
                  ? '<span class="audit-status pass"></span>'
                  : '<span class="audit-status fail"></span>'}
                <span class="audit-label">${state.name.charAt(0).toUpperCase() + state.name.slice(1).toLowerCase()} state ${state.found ? 'defined' : 'missing'}</span>
              </div>
            `;
          });
        }
        html += '</div>';
      }

      // Design Token Usage Audit - Show token analysis in audit format
      if (currentTokenSummary && currentTokenSummary.totalTokens > 0) {
        html += '<div class="audit-section">';
        html += `
          <div class="section-header">
            <h4 class="section-title">Design Token Usage</h4>
            <div class="tooltip">
              <div class="info-icon">i</div>
              <span class="tooltiptext">
                <strong>Design Token Usage</strong><br>
                Components should use design tokens (variables and styles) instead of hard-coded values for colors, spacing, typography, etc. This ensures consistency, makes updates easier, and improves maintainability. Hard-coded values make it difficult to maintain design consistency across your product.
              </span>
            </div>
          </div>
        `;

        // Show overall token usage summary
        const tokenUsagePercentage = currentTokenSummary.totalTokens > 0
          ? Math.round((currentTokenSummary.actualTokens / currentTokenSummary.totalTokens) * 100)
          : 0;

        html += `
          <div class="audit-item">
            <span class="audit-status ${tokenUsagePercentage >= 80 ? 'pass' : tokenUsagePercentage >= 50 ? 'warning' : 'fail'}">${
              tokenUsagePercentage >= 80 ? ICO.checkCircle : tokenUsagePercentage >= 50 ? ICO.warnTriangle : ICO.xCircle
            }</span>
            <span class="audit-label">Token usage: ${currentTokenSummary.actualTokens}/${currentTokenSummary.totalTokens} properties (${tokenUsagePercentage}%)</span>
          </div>
        `;

        // Show hard-coded values as individual failures
        if (currentTokenSummary.hardCodedValues > 0) {
          html += `
            <div class="audit-item">
              <span class="audit-status fail">${ICO.xCircle}</span>
              <span class="audit-label">${currentTokenSummary.hardCodedValues} hard-coded values found (should use design tokens)</span>
            </div>
          `;

          // Show breakdown by category if available
          if (currentTokenSummary.byCategory) {
            Object.entries(currentTokenSummary.byCategory).forEach(([category, stats]) => {
              if (stats.hardCoded > 0) {
                html += `
                  <div class="audit-item" style="margin-left: 20px; opacity: 0.8;">
                    <span class="audit-status fail"></span>
                    <span class="audit-label">${toTitleCase(category)}: ${stats.hardCoded} hard-coded</span>
                  </div>
                `;
              }
            });
          }
        } else {
          html += `
            <div class="audit-item">
              <span class="audit-status pass">${ICO.checkCircle}</span>
              <span class="audit-label">All properties use design tokens</span>
            </div>
          `;
        }


        html += '</div>';

        // Update pass/total counts for this section
        totalCount += 1; // Overall token usage check
        if (tokenUsagePercentage >= 50) passCount += 1; // Pass if >= 50% token usage

        if (currentTokenSummary.hardCodedValues > 0) {
          totalCount += 1; // Hard-coded values check
          // This always fails if there are hard-coded values
        } else {
          totalCount += 1; // Hard-coded values check
          passCount += 1; // Pass if no hard-coded values
        }
      }

      // Accessibility Audit
      // Component Readiness section (property config + description)
      if (audit.componentReadiness && audit.componentReadiness.length > 0) {
        html += '<div class="audit-section">';
        html += `
          <div class="section-header">
            <h4 class="section-title">Component Readiness</h4>
            <div class="tooltip">
              <div class="info-icon">i</div>
              <span class="tooltiptext">
                <strong>Component Readiness</strong><br>
                Checks if your component is properly configured for AI tools, MCP integration, and developer handoff. This includes having configurable properties for customization and descriptions that help AI understand the component's purpose and usage patterns.
              </span>
            </div>
          </div>
        `;

        audit.componentReadiness.forEach(item => {
          totalCount++;
          const status = item.status;
          if (status === 'pass') passCount++;

          weightedTotalScore += 2;
          if (status === 'pass') {
            weightedPassScore += 2;
            console.log(`[DEBUG][READINESS] "${item.check}" = PASS  +2 points`);
          } else if (status === 'warning') {
            console.log(`[DEBUG][READINESS] "${item.check}" = WARNING  0 points`);
          } else {
            console.log(`[DEBUG][READINESS] "${item.check}" = FAIL  0 points`);
          }

          html += `
            <div class="audit-item">
              <span class="audit-status ${status}">${
                status === 'pass' ? ICO.checkCircle : status === 'warning' ? ICO.warnTriangle : ICO.xCircle
              }</span>
              <span class="audit-label">${item.check}</span>
            </div>
          `;
        });
        html += '</div>';
      }

      // Accessibility section (real WCAG-informed checks)
      if (audit.accessibility && audit.accessibility.length > 0) {
        html += '<div class="audit-section">';
        html += `
          <div class="section-header">
            <h4 class="section-title">Accessibility</h4>
            <div class="tooltip">
              <div class="info-icon">i</div>
              <span class="tooltiptext">
                <strong>Accessibility</strong><br>
                WCAG-informed checks for inclusive design. Evaluates color contrast ratios, touch target sizing, focus state availability for keyboard navigation, and minimum font sizes. These checks help ensure your component works for users with disabilities.
              </span>
            </div>
          </div>
        `;

        audit.accessibility.forEach(item => {
          totalCount++;
          const status = item.status;
          if (status === 'pass') passCount++;

          weightedTotalScore += 2;
          if (status === 'pass') {
            weightedPassScore += 2;
            console.log(`[DEBUG][ACCESSIBILITY] "${item.check}" = PASS  +2 points`);
          } else if (status === 'warning') {
            console.log(`[DEBUG][ACCESSIBILITY] "${item.check}" = WARNING  0 points`);
          } else {
            console.log(`[DEBUG][ACCESSIBILITY] "${item.check}" = FAIL  0 points`);
          }

          html += `
            <div class="audit-item">
              <span class="audit-status ${status}">${
                status === 'pass' ? ICO.checkCircle : status === 'warning' ? ICO.warnTriangle : ICO.xCircle
              }</span>
              <span class="audit-label">${item.check}</span>
              ${item.suggestion ? `<div class="tooltip" style="margin-left: 4px;"><div class="info-icon" style="font-size: 9px; width: 14px; height: 14px;">i</div><span class="tooltiptext">${item.suggestion}</span></div>` : ''}
            </div>
          `;
        });
        html += '</div>';
      }

      // Layer Naming Audit (Phase 3)  Tree layout grouped by parent path
      if (currentNamingIssues && currentNamingIssues.length > 0) {
        html += '<div class="audit-section">';
        html += `
          <div class="section-header">
            <h4 class="section-title">Layer Naming</h4>
            <div class="tooltip">
              <div class="info-icon">i</div>
              <span class="tooltiptext">
                <strong>Layer Naming</strong><br>
                Checks layer names for generic or unclear naming patterns. Semantic layer names help developers understand component structure, improve code generation quality, and make components easier to maintain.
              </span>
            </div>
          </div>
        `;

        // Compute scoring for all naming issues (scoring stays the same)
        let namingErrorCount = 0, namingWarnCount = 0, namingInfoCount = 0;
        currentNamingIssues.forEach(issue => {
          totalCount++;
          weightedTotalScore += 1.5;
          if (issue.severity === 'info') { weightedPassScore += 0.75; namingInfoCount++; }
          else if (issue.severity === 'warning') { namingWarnCount++; }
          else { namingErrorCount++; }
        });

        // Summary bar with severity breakdown and Rename All button
        html += `<div class="naming-tree-summary">
          <span>${currentNamingIssues.length} naming issue${currentNamingIssues.length !== 1 ? 's' : ''} found</span>
          <div style="display: flex; align-items: center; gap: 8px;">
            <div class="severity-counts">
              ${namingErrorCount > 0 ? `<span class="sev-count">${ICO.xCircle} ${namingErrorCount}</span>` : ''}
              ${namingWarnCount > 0 ? `<span class="sev-count">${ICO.warnTriangle} ${namingWarnCount}</span>` : ''}
              ${namingInfoCount > 0 ? `<span class="sev-count">${ICO.info} ${namingInfoCount}</span>` : ''}
            </div>
            <button class="quick-actions-btn" id="rename-all-btn" onclick="handleRenameAll()" style="font-size: 10px; padding: 3px 10px;">Rename All</button>
          </div>
        </div>`;

        // Group issues by parent path (extract parent from path)
        const grouped = {};
        currentNamingIssues.forEach(issue => {
          const pathParts = issue.path ? issue.path.split(' > ') : ['Root'];
          // Use all but last segment as group key, or 'Root' for top-level
          const parentPath = pathParts.length > 1 ? pathParts.slice(0, -1).join(' > ') : 'Root';
          if (!grouped[parentPath]) grouped[parentPath] = [];
          grouped[parentPath].push(issue);
        });

        const groupKeys = Object.keys(grouped);

        // Flatten all items for pagination (max 15 initially, +20 per "Show More")
        const allFlatItems = [];
        groupKeys.forEach(groupPath => {
          grouped[groupPath].forEach(issue => {
            allFlatItems.push({ groupPath, issue });
          });
        });

        const NAMING_INITIAL_LIMIT = 15;
        const NAMING_PAGE_SIZE = 20;
        const totalNamingItems = allFlatItems.length;

        // Scrollable container for naming items
        html += '<div id="naming-scroll-container" style="max-height: 500px; overflow-y: auto; margin-bottom: 4px;">';

        // Render items up to initial limit, grouped by path
        let itemIndex = 0;
        let currentGroup = null;

        allFlatItems.forEach((entry, i) => {
          if (i >= NAMING_INITIAL_LIMIT) return; // Only render initial batch

          // Open new group if needed
          if (entry.groupPath !== currentGroup) {
            if (currentGroup !== null) html += '</div></div>'; // Close previous group
            currentGroup = entry.groupPath;
            const groupId = 'naming-group-' + groupKeys.indexOf(entry.groupPath);
            html += `<div class="naming-tree-group">`;
            html += `<div class="naming-tree-group-header" onclick="toggleNamingGroup('${groupId}')">
              <span class="tree-arrow" id="${groupId}-arrow"></span>
              <span>${escapeHtml(entry.groupPath)}</span>
              <span class="group-count">${grouped[entry.groupPath].length}</span>
            </div>`;
            html += `<div class="naming-tree-items" id="${groupId}" style="max-height: ${grouped[entry.groupPath].length * 60}px;">`;
          }

          const issue = entry.issue;
          const severityIcon = issue.severity === 'error' ? ICO.xCircle : issue.severity === 'warning' ? ICO.warnTriangle : ICO.info;
          const severityClass = issue.severity === 'error' ? 'fail' : issue.severity === 'warning' ? 'warning' : 'info';
          const escapedCurrent = issue.currentName.replace(/'/g, "\\'").replace(/"/g, '&quot;');
          const escapedSuggested = issue.suggestedName.replace(/'/g, "\\'").replace(/"/g, '&quot;');

          html += `
            <div class="naming-tree-item" data-node-id="${issue.nodeId}" onclick="if(event.target.tagName!=='BUTTON')selectFigmaNode('${issue.nodeId}')" title="Click to select this layer in Figma">
              <span class="audit-status ${severityClass}">${severityIcon}</span>
              <div class="audit-content">
                <span class="audit-label">
                  <code style="font-size: 10px; background: var(--surface); padding: 1px 4px; border-radius: 2px;">${escapeHtml(issue.currentName)}</code>
                  <span class="naming-issue-arrow">&rarr;</span>
                  <code style="font-size: 10px; background: var(--surface); padding: 1px 4px; border-radius: 2px;">${escapeHtml(issue.suggestedName)}</code>
                </span>
                <div style="font-size: 10px; color: var(--text-tertiary); margin-top: 2px;">${issue.reason}</div>
              </div>
              <button class="audit-action-button" data-node-id="${issue.nodeId}" onclick="event.stopPropagation();previewNamingFix('${issue.nodeId}', '${escapedCurrent}', '${escapedSuggested}')" title="Rename this layer">Rename</button>
            </div>
          `;
          itemIndex++;
        });

        // Close last group
        if (currentGroup !== null) html += '</div></div>';

        html += '</div>'; // Close scroll container

        // "Show More" button if there are more items
        if (totalNamingItems > NAMING_INITIAL_LIMIT) {
          html += `<div id="naming-show-more-container" style="text-align: center; margin-top: 4px;">
            <button class="naming-tree-toggle" id="naming-show-more-btn" onclick="showMoreNamingIssues()">
              Show More (${Math.min(NAMING_PAGE_SIZE, totalNamingItems - NAMING_INITIAL_LIMIT)} of ${totalNamingItems - NAMING_INITIAL_LIMIT} remaining)
            </button>
          </div>`;
        }

        html += '</div>';
      }

      auditContent.innerHTML = html;

      // Update audit score using weighted scoring for MCP compatibility focus
      const rawPercentage = weightedTotalScore > 0 ? (weightedPassScore / weightedTotalScore) * 100 : 0;
      const score = weightedTotalScore > 0 ? Math.min(100, Math.round(rawPercentage)) : 0;
      console.log(`[DEBUG][FINAL SCORE] Raw calculation: ${weightedPassScore} / ${weightedTotalScore} = ${rawPercentage.toFixed(4)}%`);
      console.log(`[DEBUG][FINAL SCORE] After Math.round(): ${score}%`);
      console.log(`Audit scoring: ${weightedPassScore} weighted points out of ${weightedTotalScore} total = ${score}% (simple: ${passCount}/${totalCount})`);

      auditScore.innerHTML = `<span>Score: ${score}%</span>`;
      auditScore.className = `status-banner ${
        score >= 80 ? 'status-success' : score >= 60 ? 'status-warning' : 'status-error'
      }`;
      auditScore.style.cssText = 'padding: 2px 8px; font-size: 11px;';
    }

    // Update Property Cheat Sheet
    function updatePropertyCheatSheet(properties, recommendations) {
      let html = '';

      if (properties && properties.length > 0) {
        html += '<table class="property-table">';
        html += '<thead><tr><th>Property</th><th>Values</th><th>Default</th></tr></thead>';
        html += '<tbody>';

        properties.forEach(prop => {
          html += '<tr>';
          html += `<td>${toTitleCase(prop.name)}</td>`;
          html += '<td><div class="property-values-cell">';
          prop.values.forEach(value => {
            // Detect hash/ID values (hex strings > 20 chars) and display as "Instance ref"
            const isHash = /^[a-f0-9]{20,}$/i.test(value);
            const displayValue = isHash ? 'Instance ref' : value;
            html += `<span class="property-value" ${isHash ? `title="${value}"` : ''}>${displayValue}</span>`;
          });
          html += '</div></td>';
          // Apply hash detection to default column too
          const defaultVal = prop.default || '-';
          const isDefaultHash = /^[a-f0-9]{20,}$/i.test(defaultVal);
          const displayDefault = isDefaultHash ? 'Instance ref' : defaultVal;
          html += `<td><span class="property-default-value" ${isDefaultHash ? `title="${defaultVal}"` : ''}>${displayDefault}</span></td>`;
          html += '</tr>';
        });

        html += '</tbody></table>';
      }

      // Use only property recommendations (no slots), filtered against existing properties
      let allRecommendations = recommendations ? [...recommendations] : [];

      // UI-side safety net: filter out recommendations that match existing properties
      // Uses semantic equivalence to catch synonyms (e.g., "Leading icon"  "Icon Before")
      if (properties && properties.length > 0 && allRecommendations.length > 0) {
        // Semantic equivalence groups  names that refer to the same concept
        const equivalenceGroups = [
          ['icon before', 'leading icon', 'iconbefore', 'leadingicon', 'icon left', 'left icon', 'start icon', 'prefix icon'],
          ['icon after', 'trailing icon', 'iconafter', 'trailingicon', 'icon right', 'right icon', 'end icon', 'suffix icon'],
          ['slot before', 'leading slot', 'slotbefore', 'show icon before', 'has leading icon', 'icon before visible'],
          ['slot after', 'trailing slot', 'slotafter', 'show icon after', 'has trailing icon', 'icon after visible'],
          ['label', 'text', 'title', 'content'],
          ['size', 'sizing', 'component size'],
          ['disabled', 'is disabled', 'isdisabled'],
          ['loading', 'is loading', 'isloading'],
          ['width', 'full width', 'fullwidth', 'block'],
          ['variant', 'style', 'appearance', 'kind'],
          ['state', 'status', 'interaction state'],
        ];

        function getEquivalenceKeys(name) {
          const lower = name.toLowerCase().trim();
          const keys = new Set([lower]);
          for (const group of equivalenceGroups) {
            if (group.some(term => lower.includes(term) || term.includes(lower))) {
              group.forEach(term => keys.add(term));
            }
          }
          return keys;
        }

        // Build a set of all semantic keys from existing properties
        const existingKeys = new Set();
        properties.forEach(p => {
          const keys = getEquivalenceKeys(p.name);
          keys.forEach(k => existingKeys.add(k));
        });

        const beforeCount = allRecommendations.length;
        allRecommendations = allRecommendations.filter(rec => {
          const recKeys = getEquivalenceKeys(rec.name);
          // Filter if ANY of the recommendation's semantic keys overlap with existing
          for (const key of recKeys) {
            if (existingKeys.has(key)) return false;
          }
          // Also check direct substring match as fallback
          const recName = rec.name.toLowerCase();
          const existingNames = properties.map(p => p.name.toLowerCase());
          return !existingNames.some(existing =>
            existing === recName ||
            existing.includes(recName) ||
            recName.includes(existing)
          );
        });
        if (allRecommendations.length < beforeCount) {
          console.log(`[CONFIG] Filtered ${beforeCount - allRecommendations.length} recommendations that matched existing properties (semantic matching)`);
        }
      }

      _currentRecommendations = allRecommendations; // Store for clipboard access

      console.log('[CONFIG] Property recommendations after filtering:', allRecommendations.length);

      // Add recommendations section if available
      if (allRecommendations && allRecommendations.length > 0) {
        if (html) html += '<div style="margin-top: 20px; border-top: 1px solid var(--border); padding-top: 16px;"></div>';

        html += '<div class="recommendations-section">';
        html += '<h4 style="font-size: 12px; font-weight: 600; margin-bottom: 12px; margin-top: 0; color: var(--primary);">Recommended Properties</h4>';
        html += '<p style="font-size: 11px; color: var(--text-secondary); margin-bottom: 12px;">Consider adding these properties that developers typically expect for this component type:</p>';

        allRecommendations.forEach((rec, index) => {
          const typeColor = rec.type === 'slot' ? 'var(--warning)' : 'var(--interactive)';

          html += `
            <div class="recommendation-card" id="rec-card-${index}" style="background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius-md); padding: 12px; margin-bottom: 8px;">
              <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                <span style="font-weight: 600; font-size: 12px;">${rec.name}</span>
                <span style="background: ${typeColor}; color: var(--text-on-color); padding: 2px 6px; border-radius: var(--radius-sm); font-size: 9px; text-transform: uppercase; font-weight: 500;">${rec.type}</span>
              </div>
              <p style="font-size: 11px; color: var(--text-secondary); margin: 0 0 6px 0;">${rec.description}</p>
              <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                ${rec.examples.map(example => `<span class="property-value">${example}</span>`).join('')}
              </div>
            </div>
          `;
        });

        html += '</div>';
      }

      // Show fallback content when no properties and no recommendations
      if (!html) {
        html = `
          <div style="text-align: center; padding: var(--space-lg); color: var(--text-tertiary);">
            <p>This component has no configurable properties</p>
            <p style="font-size: 11px; margin-top: var(--space-xs);">Simple components may not have customizable props</p>
          </div>
        `;
      }

      propertyCheatsheet.innerHTML = html;
    }

    // Enhanced Token Analysis Display
    function updateTokenSuggestions(tokens) {
      console.log('UI updateTokenSuggestions called with:', tokens);

      let html = '';

      // Display token summary if available
      if (currentTokenSummary) {
        html += '<div class="token-summary" style="background: var(--surface-secondary); border-bottom: 1px solid var(--border); padding-bottom: 12px; margin-bottom: 16px;">';
        html += '<h4 style="font-size: 12px; font-weight: 600; margin-bottom: 8px; margin-top: 0;">Token Analysis Summary</h4>';
        html += '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; font-size: 11px;">';
        html += `<div><strong>Total Items:</strong> ${currentTokenSummary.totalTokens}</div>`;
        html += `<div><strong>Design Tokens:</strong> <span style="color: var(--success)">${currentTokenSummary.actualTokens}</span></div>`;
        html += `<div><strong>Hard-coded:</strong> <span style="color: var(--warning)">${currentTokenSummary.hardCodedValues}</span></div>`;
        html += `<div><strong>AI Suggestions:</strong> <span style="color: var(--primary)">${currentTokenSummary.aiSuggestions}</span></div>`;
        html += '</div>';

        // Show breakdown by category
        if (currentTokenSummary.byCategory) {
          html += '<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border);">';
          html += '<div style="font-size: 10px; color: var(--text-tertiary); margin-bottom: 4px;">By Category:</div>';
          html += '<div style="display: flex; gap: 12px; flex-wrap: wrap; font-size: 10px;">';
          Object.entries(currentTokenSummary.byCategory).forEach(([category, stats]) => {
            if (stats.total > 0) {
              html += `<div><strong>${category}:</strong> ${stats.tokens}/${stats.total}</div>`;
            }
          });
          html += '</div>';
          html += '</div>';
        }


        html += '</div>';
      }

      // Hard-coded values info bar
      if (currentTokenSummary && currentTokenSummary.hardCodedValues > 0) {
        html += `
          <div class="batch-action-bar">
            <span class="batch-label">${ICO.warnTriangle} ${currentTokenSummary.hardCodedValues} hard-coded value${currentTokenSummary.hardCodedValues !== 1 ? 's' : ''} found</span>
          </div>
        `;
      }

      // Colors - Enhanced with comprehensive analysis
      if (tokens.colors && Array.isArray(tokens.colors) && tokens.colors.length > 0) {
        console.log('Processing color tokens:', tokens.colors);
        html += '<div class="mb-md">';
        html += '<h4 style="font-size: 12px; font-weight: 600; margin-bottom: 4px;">Color Tokens</h4>';

        // Separate actual tokens from hard-coded values
        console.log('Color tokens before filtering:', tokens.colors);
        const actualTokens = tokens.colors.filter(token => token.isActualToken);
        const hardCodedTokens = tokens.colors.filter(token => !token.isActualToken && token.source === 'hard-coded' && !token.isDefaultVariantStyle);
        const defaultVariantTokens = tokens.colors.filter(token => !token.isActualToken && token.source === 'hard-coded' && token.isDefaultVariantStyle);
        const aiSuggestions = tokens.colors.filter(token => token.source === 'ai-suggestion');

        console.log('Filtered results:', {
          actualTokens: actualTokens.length,
          hardCodedTokens: hardCodedTokens.length,
          aiSuggestions: aiSuggestions.length,
          hardCodedDetails: hardCodedTokens
        });

        // Show actual design tokens first
        if (actualTokens.length > 0) {
          html += '<div style="margin-bottom: 12px;">';
          html += '<h5 style="font-size: 11px; font-weight: 500; color: var(--success); margin-bottom: 4px;">Design Tokens in Use</h5>';
          actualTokens.forEach(token => {
            html += `
              <div class="token-item-compact">
                <div class="token-swatch" style="background: ${token.value};" title="${token.value}"></div>
                <div class="token-details">
                  <div class="token-name">${token.name}</div>
                  <div class="token-usage" title="${token.recommendation}">${token.recommendation}</div>
                </div>
              </div>
            `;
          });
          html += '</div>';
        }

        // Show hard-coded colors with enhanced context
        if (hardCodedTokens.length > 0) {
          html += '<div style="margin-bottom: 12px;" id="section-colors">';
          const clrFixAll = hardCodedTokens.filter(t => t.context?.nodeId && t.context?.property).length > 1
            ? `<button class="fix-btn" onclick="event.stopPropagation();batchFixAllTokens('section-colors')" title="Fix all hard-coded colors" style="margin-left: 6px; font-size: 10px;">Fix All</button>` : '';
          html += `<h5 style="font-size: 11px; font-weight: 500; color: var(--warning); margin-bottom: 4px; display: flex; align-items: center;">Hard-coded Colors${clrFixAll}</h5>`;
          hardCodedTokens.forEach(token => {
            const contextInfo = token.context ?
              `${token.context.nodeType} in "${token.context.nodeName}"${token.context.isInteractive ? ' (Interactive)' : ''}` :
              'Unknown context';

            const fixButton = token.context?.nodeId && token.context?.property ?
              `<button class="fix-btn" data-node-id="${token.context.nodeId}" onclick="event.stopPropagation();previewTokenFix('${token.context.nodeId}', '${token.context.property || 'fills[0]'}', '${token.value}')" title="Fix this hard-coded value">Fix</button>` : '';

            html += `
              <div class="token-item-compact warning" ${token.context?.nodeId ? `onclick="selectFigmaNode('${token.context.nodeId}')" style="cursor: pointer;" title="Click to select in Figma"` : ''}>
                <div class="token-swatch" style="background: ${token.value};" title="${token.value}"></div>
                <div class="token-details">
                  <div class="token-name">${token.value}</div>
                  <div class="token-usage" title="${contextInfo} - ${token.suggestion}">${token.suggestion}</div>
                </div>
                <div class="token-actions">
                  ${fixButton}
                </div>
              </div>
            `;
          });
          html += '</div>';
        }

        // Show AI suggested tokens
        if (aiSuggestions.length > 0) {
          html += '<div>';
          html += '<h5 style="font-size: 11px; font-weight: 500; color: var(--primary); margin-bottom: 4px;">AI Suggested Tokens</h5>';
          aiSuggestions.forEach(token => {
            html += `
              <div class="token-item-compact suggestion">
                <div class="token-swatch" style="background: ${token.value};" title="${token.value}"></div>
                <div class="token-details">
                  <div class="token-name">${token.name}</div>
                  <div class="token-usage" title="${token.recommendation || token.suggestion || 'AI suggested token'}">${token.recommendation || token.suggestion || 'AI suggested token'}</div>
                </div>
              </div>
            `;
          });
          html += '</div>';
        }


        html += '</div>';
      }

      // Effects - New comprehensive section
      if (tokens.effects && Array.isArray(tokens.effects) && tokens.effects.length > 0) {
        html += '<hr class="token-section-divider">';
        html += '<div class="mb-md">';
        html += '<h4 style="font-size: 12px; font-weight: 600; margin-bottom: 4px;">Effect Tokens</h4>';

        const actualEffectTokens = tokens.effects.filter(token => token.isActualToken);
        const hardCodedEffects = tokens.effects.filter(token => !token.isActualToken && !token.isDefaultVariantStyle);

        if (actualEffectTokens.length > 0) {
          html += '<div style="margin-bottom: 12px;">';
          html += '<h5 style="font-size: 11px; font-weight: 500; color: var(--success); margin-bottom: 4px;">Effect Tokens in Use</h5>';
          actualEffectTokens.forEach(token => {
            html += `
              <div class="token-item-compact">
                <div class="token-details">
                  <div class="token-name">${token.name}</div>
                  <div class="token-usage" title="${token.recommendation}">${token.recommendation}</div>
                </div>
              </div>
            `;
          });
          html += '</div>';
        }

        if (hardCodedEffects.length > 0) {
          html += '<div>';
          html += '<h5 style="font-size: 11px; font-weight: 500; color: var(--warning); margin-bottom: 4px;">Hard-coded Effects</h5>';
          hardCodedEffects.forEach(token => {
            const contextInfo = token.context ? `${token.context.nodeType} in "${token.context.nodeName}"` : 'Unknown context';

            html += `
              <div class="token-item-compact warning" ${token.context?.nodeId ? `onclick="selectFigmaNode('${token.context.nodeId}')" style="cursor: pointer;" title="Click to select in Figma"` : ''}>
                <div class="token-details">
                  <div class="token-name">${token.type}</div>
                  <div class="token-usage" title="${contextInfo} - ${token.suggestion}">${token.suggestion}</div>
                </div>
              </div>
            `;
          });
          html += '</div>';
        }

        html += '</div>';
      }

      // Borders - New comprehensive section
      if (tokens.borders && Array.isArray(tokens.borders) && tokens.borders.length > 0) {
        html += '<hr class="token-section-divider">';
        html += '<div class="mb-md">';
        html += '<h4 style="font-size: 12px; font-weight: 600; margin-bottom: 4px;">Border Tokens</h4>';

        const actualBorderTokens = tokens.borders.filter(token => token.isActualToken);
        const hardCodedBorders = tokens.borders.filter(token => !token.isActualToken && !token.isDefaultVariantStyle);
        const defaultBorders = tokens.borders.filter(token => !token.isActualToken && token.isDefaultVariantStyle);

        if (actualBorderTokens.length > 0) {
          html += '<div style="margin-bottom: 12px;">';
          html += '<h5 style="font-size: 11px; font-weight: 500; color: var(--success); margin-bottom: 4px;">Border Tokens in Use</h5>';
          actualBorderTokens.forEach(token => {
            html += `
              <div class="token-item-compact">
                <div class="token-details">
                  <div class="token-name">${token.name}</div>
                  <div class="token-usage" title="${token.recommendation}">${token.recommendation}</div>
                </div>
              </div>
            `;
          });
          html += '</div>';
        }

        if (hardCodedBorders.length > 0) {
          // Separate stroke weights from border radius
          const strokeWeights = hardCodedBorders.filter(token =>
            token.type === 'stroke-weight' ||
            (token.context && token.context.property === 'strokeWeight')
          );
          const borderRadius = hardCodedBorders.filter(token =>
            token.type !== 'stroke-weight' &&
            !(token.context && token.context.property === 'strokeWeight')
          );

          // Stroke Weight Section
          if (strokeWeights.length > 0) {
            html += '<div style="margin-bottom: 12px;" id="section-stroke-weight">';
            const swFixAll = strokeWeights.filter(t => t.context?.nodeId && t.context?.property).length > 1
              ? `<button class="fix-btn" onclick="event.stopPropagation();batchFixAllTokens('section-stroke-weight')" title="Fix all hard-coded stroke weights" style="margin-left: 6px; font-size: 10px;">Fix All</button>` : '';
            html += `<h5 style="font-size: 11px; font-weight: 500; color: var(--warning); margin-bottom: 4px; display: flex; align-items: center;">Hard-coded Stroke Weight${swFixAll}</h5>`;
            strokeWeights.forEach(token => {
              // Use the enhanced debug context for better information
              let contextInfo = 'Unknown location';
              if (token.context) {
                if (token.context.description) {
                  contextInfo = token.context.description;
                } else if (token.context.path) {
                  contextInfo = `Found in: ${token.context.path}`;
                } else {
                  contextInfo = `${token.context.nodeType} in "${token.context.nodeName}"`;
                }

                // Add property information if available
                if (token.context.property) {
                  contextInfo += ` (${token.context.property})`;
                }
              }

              const fixButton = token.context?.nodeId && token.context?.property ?
                `<button class="fix-btn" onclick="event.stopPropagation();previewTokenFix('${token.context.nodeId}', '${token.context.property}', '${token.value}')" title="Fix this hard-coded value">Fix</button>` : '';

              html += `
                <div class="token-item-compact warning" ${token.context?.nodeId ? `onclick="selectFigmaNode('${token.context.nodeId}')" style="cursor: pointer;" title="Click to select in Figma"` : ''}>
                  <div class="token-details">
                    <div class="token-name">${token.value}</div>
                    <div class="token-usage" style="font-size: 10px; color: var(--text-secondary);">${contextInfo}</div>
                    <div class="token-usage" style="font-size: 10px; margin-top: 2px; font-style: italic;">Use appropriate stroke weight token (e.g., stroke.thin, stroke.medium)</div>
                  </div>
                  <div class="token-actions">
                    ${fixButton}
                  </div>
                </div>
              `;
            });
            html += '</div>';
          }

          // Border Radius Section
          if (borderRadius.length > 0) {
            html += '<div id="section-border-radius">';
            const brFixAll = borderRadius.filter(t => t.context?.nodeId && t.context?.property).length > 1
              ? `<button class="fix-btn" onclick="event.stopPropagation();batchFixAllTokens('section-border-radius')" title="Fix all hard-coded border radii" style="margin-left: 6px; font-size: 10px;">Fix All</button>` : '';
            html += `<h5 style="font-size: 11px; font-weight: 500; color: var(--warning); margin-bottom: 4px; display: flex; align-items: center;">Hard-coded Border Radius${brFixAll}</h5>`;
            borderRadius.forEach(token => {
              // Use the enhanced debug context for better information
              let contextInfo = 'Unknown location';
              if (token.context) {
                if (token.context.description) {
                  contextInfo = token.context.description;
                } else if (token.context.path) {
                  contextInfo = `Found in: ${token.context.path}`;
                } else {
                  contextInfo = `${token.context.nodeType} in "${token.context.nodeName}"`;
                }

                // Add property information if available
                if (token.context.property) {
                  contextInfo += ` (${token.context.property})`;
                }
              }

              const fixButton = token.context?.nodeId && token.context?.property ?
                `<button class="fix-btn" onclick="event.stopPropagation();previewTokenFix('${token.context.nodeId}', '${token.context.property}', '${token.value}')" title="Fix this hard-coded value">Fix</button>` : '';

              html += `
                <div class="token-item-compact warning" ${token.context?.nodeId ? `onclick="selectFigmaNode('${token.context.nodeId}')" style="cursor: pointer;" title="Click to select in Figma"` : ''}>
                  <div class="token-details">
                    <div class="token-name">${token.value}</div>
                    <div class="token-usage" style="font-size: 10px; color: var(--text-secondary);">${contextInfo}</div>
                    <div class="token-usage" style="font-size: 10px; margin-top: 2px; font-style: italic;">${token.suggestion}</div>
                  </div>
                  <div class="token-actions">
                    ${fixButton}
                  </div>
                </div>
              `;
            });
            html += '</div>';
          }
        }


        html += '</div>';
      }

      // Spacing - Enhanced with better context
      if (tokens.spacing && Array.isArray(tokens.spacing) && tokens.spacing.length > 0) {
        html += '<hr class="token-section-divider">';
        html += '<div class="mb-md">';
        html += '<h4 style="font-size: 12px; font-weight: 600; margin-bottom: 4px;">Spacing Tokens</h4>';

        const actualSpacingTokens = tokens.spacing.filter(token => token.isActualToken);
        const hardCodedSpacing = tokens.spacing.filter(token => !token.isActualToken && !token.isDefaultVariantStyle);
        const defaultSpacing = tokens.spacing.filter(token => !token.isActualToken && token.isDefaultVariantStyle);

        if (actualSpacingTokens.length > 0) {
          html += '<div style="margin-bottom: 12px;">';
          html += '<h5 style="font-size: 11px; font-weight: 500; color: var(--success); margin-bottom: 4px;">Spacing Tokens in Use</h5>';
          actualSpacingTokens.forEach(token => {
            html += `
              <div class="token-item-compact">
                <div class="token-details">
                  <div class="token-name">${token.name}</div>
                  <div class="token-usage" title="${token.recommendation}">${token.recommendation}</div>
                </div>
              </div>
            `;
          });
          html += '</div>';
        }

        if (hardCodedSpacing.length > 0) {
          html += '<div id="section-spacing">';
          const spFixAll = hardCodedSpacing.filter(t => t.context?.nodeId && t.context?.property).length > 1
            ? `<button class="fix-btn" onclick="event.stopPropagation();batchFixAllTokens('section-spacing')" title="Fix all hard-coded spacing" style="margin-left: 6px; font-size: 10px;">Fix All</button>` : '';
          html += `<h5 style="font-size: 11px; font-weight: 500; color: var(--warning); margin-bottom: 4px; display: flex; align-items: center;">Hard-coded Spacing${spFixAll}</h5>`;
          hardCodedSpacing.forEach(token => {
            // Use the enhanced debug context for better information
            let contextInfo = 'Unknown location';
            if (token.context) {
              if (token.context.description) {
                contextInfo = token.context.description;
              } else if (token.context.path) {
                contextInfo = `Found in: ${token.context.path}`;
              } else {
                contextInfo = `${token.context.paddingType || token.type} on "${token.context.nodeName}" (${token.context.nodeType})`;
              }

              // Add property information if available
              if (token.context.property) {
                contextInfo += ` (${token.context.property})`;
              }
            }

            const fixButton = token.context?.nodeId && token.context?.property ?
              `<button class="fix-btn" onclick="event.stopPropagation();previewTokenFix('${token.context.nodeId}', '${token.context.property}', '${token.value}')" title="Fix this hard-coded value">Fix</button>` : '';

            html += `
              <div class="token-item-compact warning" ${token.context?.nodeId ? `onclick="selectFigmaNode('${token.context.nodeId}')" style="cursor: pointer;" title="Click to select in Figma"` : ''}>
                <div class="token-details">
                  <div class="token-name">${token.value}</div>
                  <div class="token-usage" style="font-size: 10px; color: var(--text-secondary);">${contextInfo}</div>
                  <div class="token-usage" style="font-size: 10px; margin-top: 2px; font-style: italic;">${token.suggestion || 'Create or use existing spacing token'}</div>
                </div>
                <div class="token-actions">
                  ${fixButton}
                </div>
              </div>
            `;
          });
          html += '</div>';
        }


        html += '</div>';
      }

      // Typography - Enhanced with better context
      if (tokens.typography && Array.isArray(tokens.typography) && tokens.typography.length > 0) {
        html += '<hr class="token-section-divider">';
        html += '<div>';
        html += '<h4 style="font-size: 12px; font-weight: 600; margin-bottom: 4px;">Typography Tokens</h4>';

        const actualTypographyTokens = tokens.typography.filter(token => token.isActualToken);
        const hardCodedTypography = tokens.typography.filter(token => !token.isActualToken && !token.isDefaultVariantStyle);

        if (actualTypographyTokens.length > 0) {
          html += '<div style="margin-bottom: 12px;">';
          html += '<h5 style="font-size: 11px; font-weight: 500; color: var(--success); margin-bottom: 4px;">Typography Tokens in Use</h5>';
          actualTypographyTokens.forEach(token => {
            html += `
              <div class="token-item-compact">
                <div class="token-preview-text" style="font-size: ${token.value || '14px'}; font-weight: ${token.context && token.context.fontWeight ? token.context.fontWeight : '400'};">Aa</div>
                <div class="token-details">
                  <div class="token-name">${token.name}</div>
                  <div class="token-usage" title="${token.recommendation}">${token.recommendation}</div>
                </div>
              </div>
            `;
          });
          html += '</div>';
        }

        if (hardCodedTypography.length > 0) {
          html += '<div>';
          html += '<h5 style="font-size: 11px; font-weight: 500; color: var(--warning); margin-bottom: 4px;">Hard-coded Typography</h5>';
          hardCodedTypography.forEach(token => {
            const contextInfo = token.context ?
              `${token.context.fontFamily} in "${token.context.textContent || 'text element'}"` :
              'Unknown context';

            html += `
              <div class="token-item-compact warning" ${token.context?.nodeId ? `onclick="selectFigmaNode('${token.context.nodeId}')" style="cursor: pointer;" title="Click to select in Figma"` : ''}>
                <div class="token-preview-text" style="font-size: ${token.value || '14px'}; font-weight: ${token.context && token.context.fontWeight ? token.context.fontWeight : '400'};">Aa</div>
                <div class="token-details">
                  <div class="token-name">${token.value}</div>
                  <div class="token-usage" title="${contextInfo} - ${token.suggestion}">${token.suggestion}</div>
                </div>
              </div>
            `;
          });
          html += '</div>';
        }

        html += '</div>';
      }

      // Show comprehensive summary if no tokens found
      if (html === '') {
        html = `
          <div style="text-align: center; padding: var(--space-lg); color: var(--text-tertiary);">
            <p><strong>No design tokens detected</strong></p>
            <p style="font-size: 11px; margin-top: var(--space-xs);">This component uses simple styling without extractable design tokens.</p>
            <p style="font-size: 11px; margin-top: var(--space-xs);">Consider using Figma variables for colors, spacing, and typography to improve consistency.</p>
          </div>
        `;
      } else {
        // Add summary statistics
        const allTokens = [
          ...(tokens.colors || []),
          ...(tokens.spacing || []),
          ...(tokens.typography || []),
          ...(tokens.effects || []),
          ...(tokens.borders || [])
        ];

        // Exclude default variant styles from counts
        const nonDefaultTokens = allTokens.filter(token => !token.isDefaultVariantStyle);
        const totalTokens = nonDefaultTokens.length;
        const actualTokensCount = nonDefaultTokens.filter(token => token.isActualToken).length;
        const hardCodedCount = nonDefaultTokens.filter(token => !token.isActualToken && token.source === 'hard-coded').length;

        // Removed redundant compact token summary - detailed summary above provides better info
      }

      tokenSuggestions.innerHTML = html;
    }

    // Update Metadata Display
    function updateMetadataDisplay(metadata) {
      let html = '';

      // Description Action Bar (Phase 5)
      if (lastAnalyzedNodeId && metadata.description) {
        html += `
          <div class="metadata-action-bar">
            <span class="action-label">AI-generated description available</span>
            <button class="audit-action-button" onclick="handleUpdateDescription()">Update Description</button>
          </div>
        `;
      }

      // Component Info
      html += `<div class="mb-md">`;
      html += `<h3 style="font-size: 13px; font-weight: 600; margin-top: 0;">${metadata.component}</h3>`;
      html += `<p style="color: var(--text-secondary);">${metadata.description}</p>`;
      html += `</div>`;

      // Properties
      if (metadata.props && metadata.props.length > 0) {
        html += '<div class="mb-md">';
        html += '<h4 style="font-size: 12px; font-weight: 600; margin-bottom: 8px;">Properties</h4>';
                html += '<div style="display: flex; flex-wrap: wrap; gap: 4px;">';

        metadata.props.forEach(prop => {
          // Handle both object format and string format
          const propName = typeof prop === 'string' ? prop : (prop.name || prop);
          const formattedPropName = toTitleCase(propName);
          html += `<span class="property-value">${formattedPropName}</span>`;
        });
        html += '</div></div>';
      }

      // States (deduplicated and cleaned)
      if (metadata.states && metadata.states.length > 0) {
        // Remove duplicates and empty values
        const uniqueStates = [...new Set(metadata.states)]
          .filter(state => state && typeof state === 'string' && state.trim() !== '')
          .map(state => state.trim());

        if (uniqueStates.length > 0) {
          html += '<div class="mb-md">';
          html += '<h4 style="font-size: 12px; font-weight: 600; margin-bottom: 8px;">States</h4>';
          html += '<div style="display: flex; flex-wrap: wrap; gap: 4px;">';
          uniqueStates.forEach(state => {
            html += `<span class="property-value" style="background: #E7F9F0; color: var(--success);">${state}</span>`;
          });
          html += '</div></div>';
        }
      }

      // Slots (temporarily removed from metadata display - will be moved to property recommendations)
      // if (metadata.slots && metadata.slots.length > 0) {
      //   html += '<div class="mb-md">';
      //   html += '<h4 style="font-size: 12px; font-weight: 600; margin-bottom: 8px;">Slots</h4>';
      //   html += '<div style="display: flex; flex-wrap: wrap; gap: 4px;">';
      //   metadata.slots.forEach(slot => {
      //     const slotName = typeof slot === 'string' ? slot : (slot.name || 'Unnamed Slot');
      //     html += `<span class="property-value" style="background: #FFF4E0; color: var(--warning);">${slotName}</span>`;
      //   });
      //   html += '</div></div>';
      // }

      metadataContent.innerHTML = html;
    }

    // Update MCP Readiness Section
    function updateMCPReadiness(mcpData) {
      console.log('[DEBUG] AI interpretation data received:', mcpData);

      if (!mcpData) {
        mcpReadiness.innerHTML = '<p style="color: var(--text-tertiary); text-align: center; padding: 20px;">AI interpretation analysis not available</p>';
        return;
      }

      let html = '';

      // Narrative intro about what AI sees
      html += '<div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px; line-height: 1.5;">';
      html += 'If an AI tool were to consume this component as-is, here is how it would interpret the design structure. Fix the items flagged in the Component Audit above to improve this interpretation.';
      html += '</div>';

      // What AI reads well (Strengths)
      if (mcpData.strengths && mcpData.strengths.length > 0) {
        html += '<div class="mb-md">';
        html += '<h4 style="font-size: 12px; font-weight: 600; margin-bottom: 4px; color: var(--success); margin-top: 0;">What AI Reads Well</h4>';
        html += '<ul style="margin: 0; padding-left: 16px; font-size: 12px; list-style: disc;">';
        mcpData.strengths.forEach(strength => {
          html += `<li style="margin-bottom: 2px;">${strength}</li>`;
        });
        html += '</ul>';
        html += '</div>';
      }

      // Where AI gets confused (Gaps)
      if (mcpData.gaps && mcpData.gaps.length > 0) {
        html += '<div class="mb-md">';
        html += '<h4 style="font-size: 12px; font-weight: 600; margin-bottom: 4px; color: var(--error);">Where AI Gets Confused</h4>';
        html += '<ul style="margin: 0; padding-left: 16px; font-size: 12px; list-style: disc;">';
        mcpData.gaps.forEach(gap => {
          html += `<li style="margin-bottom: 2px;">${gap}</li>`;
        });
        html += '</ul>';
        html += '</div>';
      }

      // How to improve AI understanding (Recommendations)
      if (mcpData.recommendations && mcpData.recommendations.length > 0) {
        html += '<div class="mb-md">';
        html += '<h4 style="font-size: 12px; font-weight: 600; margin-bottom: 4px; color: var(--primary);">How to Improve AI Understanding</h4>';
        html += '<ul style="margin: 0; padding-left: 16px; font-size: 12px; list-style: disc;">';
        mcpData.recommendations.forEach(rec => {
          html += `<li style="margin-bottom: 2px;">${rec}</li>`;
        });
        html += '</ul>';
        html += '</div>';
      }

      // Implementation Notes
      if (mcpData.implementationNotes) {
        html += '<div class="mb-md">';
        html += '<h4 style="font-size: 12px; font-weight: 600; margin-bottom: 4px;">What AI Would Generate</h4>';
        html += `<div style="font-size: 12px; background: var(--surface); padding: 10px 12px; border-radius: 6px; border: 1px solid var(--border); color: var(--text-secondary); line-height: 1.5;">${mcpData.implementationNotes}</div>`;
        html += '</div>';
      }

      // Show fallback if no content
      if (!html) {
        html = '<p style="color: var(--text-tertiary); text-align: center; padding: 20px;">AI interpretation data not available</p>';
      }

      mcpReadiness.innerHTML = html;
    }

    // Update Developer Export Section
    function updateDeveloperExport(metadata) {
      const developerExportSection = document.getElementById('developer-export');

      if (!metadata) {
        exportMetadataButton.disabled = true;
        developerExportSection.innerHTML = `
          <div class="export-options" style="margin-bottom: var(--space-md);">
            <select id="export-format" class="w-full">
              <option value="json">JSON: Complete component metadata</option>
              <option value="markdown" selected>Markdown: Developer documentation</option>
            </select>
            <button class="button button-secondary" id="export-metadata" disabled>
              Export for Developers
            </button>
          </div>
          <p style="color: var(--text-tertiary); text-align: center; padding: 20px;">No analysis results available</p>
        `;
        return;
      }

      exportMetadataButton.disabled = false;

      // Clear existing content and show proper preview
      const previewHtml = `
        <div class="export-options" style="margin-bottom: var(--space-md);">
          <select id="export-format" class="w-full">
            <option value="json">JSON: Complete component metadata</option>
            <option value="markdown" selected>Markdown: Developer documentation</option>
          </select>
          <button class="button button-secondary" id="export-metadata">
            Export for Developers
          </button>
        </div>
        <div style="font-size: 12px; color: var(--text-secondary);">
          <div style="margin-bottom: 8px;"><strong>Available exports:</strong></div>
          <div style="margin-bottom: 4px;"> JSON: Complete component metadata</div>
          <div style="margin-bottom: 4px;"> Markdown: Developer documentation</div>
        </div>
      `;

      developerExportSection.innerHTML = previewHtml;

      // Re-attach event listener since we replaced the button
      const newExportButton = document.getElementById('export-metadata');
      if (newExportButton) {
        newExportButton.addEventListener('click', handleExportMetadata);
      }
    }

    // Update Playground Tab
    function updatePlaygroundTab() {
      if (!currentMetadata) return;

      if (playgroundEmpty) {
        playgroundEmpty.classList.add('hidden');
      }
      if (playgroundContent) {
        playgroundContent.classList.remove('hidden');
      }

      // Update playground preview
      if (playgroundGrid) {
        let html = '';
        const hasContent = (currentMetadata.states && currentMetadata.states.length > 0) ||
                          (currentMetadata.variants && Object.keys(currentMetadata.variants).length > 0);

        if (hasContent) {
          html = '<p style="text-align: center; color: var(--text-secondary); margin-bottom: 16px;">Click "Generate Instances" to create a visual playground of all component variations</p>';
        } else {
          html = '<p style="text-align: center; color: var(--text-tertiary);">No variants or states detected for this component</p>';
        }

        playgroundGrid.innerHTML = html;
      }
    }

    // Update Documentation Tab
    function updateDocumentationTab() {
      if (!currentMetadata) return;

      if (docsEmpty) {
        docsEmpty.classList.add('hidden');
      }
      if (docsPreview) {
        docsPreview.classList.remove('hidden');
        // Generate documentation preview
        const docsHtml = generateDocumentationHTML(currentMetadata);
        docsPreview.innerHTML = docsHtml;
      }

      // Enable buttons with null checks
      if (exportDocsButton) {
        exportDocsButton.disabled = false;
      }
      if (generateDocsFrameButton) {
        generateDocsFrameButton.disabled = false;
      }
      if (saveNotesButton) {
        saveNotesButton.disabled = false;
      }
    }

    // Generate Documentation HTML
    function generateDocumentationHTML(metadata) {
      let html = '';

      html += '<div class="doc-section">';
      html += `<h2 class="doc-heading">${metadata.component}</h2>`;
      html += `<p class="doc-content">${metadata.description}</p>`;
      html += '</div>';

      if (metadata.props && metadata.props.length > 0) {
        html += '<div class="doc-section">';
        html += '<h3 class="doc-heading">Properties</h3>';
        html += '<ul class="doc-content">';
        metadata.props.forEach(prop => {
          // Handle both object format and string format
          const propName = typeof prop === 'string' ? prop : (prop.name || prop);
          html += `<li>${propName}</li>`;
        });
        html += '</ul>';
        html += '</div>';
      }

      if (metadata.states && metadata.states.length > 0) {
        html += '<div class="doc-section">';
        html += '<h3 class="doc-heading">States</h3>';
        html += '<ul class="doc-content">';
        metadata.states.forEach(state => {
          html += `<li>${state}</li>`;
        });
        html += '</ul>';
        html += '</div>';
      }

      if (metadata.usage) {
        html += '<div class="doc-section">';
        html += '<h3 class="doc-heading">Usage Guidelines</h3>';
        html += `<p class="doc-content">${metadata.usage}</p>`;
        html += '</div>';
      }

      if (metadata.accessibility) {
        html += '<div class="doc-section">';
        html += '<h3 class="doc-heading">Accessibility</h3>';
        html += `<p class="doc-content">${metadata.accessibility}</p>`;
        html += '</div>';
      }

      return html;
    }

    // Export as Markdown
    function exportAsMarkdown() {
      if (!currentMetadata) return;

      let markdown = `# ${currentMetadata.component}\n\n`;
      markdown += `${currentMetadata.description}\n\n`;

      if (currentMetadata.props && currentMetadata.props.length > 0) {
        markdown += `## Properties\n\n`;
        currentMetadata.props.forEach(prop => {
          // Handle both object format and string format
          const propName = typeof prop === 'string' ? prop : (prop.name || prop);
          markdown += `- ${propName}\n`;
        });
        markdown += '\n';
      }

      if (currentMetadata.states && currentMetadata.states.length > 0) {
        markdown += `## States\n\n`;
        currentMetadata.states.forEach(state => {
          markdown += `- ${state}\n`;
        });
        markdown += '\n';
      }

      if (currentMetadata.slots && currentMetadata.slots.length > 0) {
        markdown += `## Slots\n\n`;
        currentMetadata.slots.forEach(slot => {
          markdown += `- ${slot}\n`;
        });
        markdown += '\n';
      }

      if (currentMetadata.usage) {
        markdown += `## Usage Guidelines\n\n${currentMetadata.usage}\n\n`;
      }

      if (currentMetadata.accessibility) {
        markdown += `## Accessibility\n\n${currentMetadata.accessibility}\n\n`;
      }

      // Copy to clipboard
      navigator.clipboard.writeText(markdown).then(() => {
        updateStatus('Markdown copied to clipboard!', 'success');
      });
    }

    // Export as JSON
    function exportAsJSON() {
      if (!currentMetadata) return;

      const jsonStr = JSON.stringify(currentMetadata, null, 2);

      // Copy to clipboard
      navigator.clipboard.writeText(jsonStr).then(() => {
        updateStatus('JSON copied to clipboard!', 'success');
      });
    }

    // Show Loading State
    function showLoadingState() {
      auditContent.innerHTML = '<div class="skeleton"></div><div class="skeleton" style="width: 80%;"></div><div class="skeleton" style="width: 60%;"></div>';
      propertyCheatsheet.innerHTML = '<div class="skeleton"></div><div class="skeleton" style="width: 70%;"></div>';
      tokenSuggestions.innerHTML = '<div class="skeleton"></div><div class="skeleton" style="width: 90%;"></div>';
      metadataContent.innerHTML = '<div class="skeleton"></div><div class="skeleton" style="width: 85%;"></div>';
    }

    // Update UI Button States
    function updateUIButtonStates() {
      const hasMetadata = currentMetadata !== null;

      if (generatePlaygroundButton) {
        generatePlaygroundButton.disabled = !hasMetadata;
      }
      if (exportDocsButton) {
        exportDocsButton.disabled = !hasMetadata;
      }
      if (generateDocsFrameButton) {
        generateDocsFrameButton.disabled = !hasMetadata;
      }
      if (saveNotesButton) {
        saveNotesButton.disabled = !hasMetadata;
      }
    }

    // Handle Playground Generated
    function handlePlaygroundGenerated(data) {
      if (generatePlaygroundButton) {
        generatePlaygroundButton.disabled = false;
      }
      if (data.success) {
        updateStatus(data.message || 'Playground generated successfully!', 'success');
        // Switch to playground tab
        switchTab('playground');
      } else {
        updateStatus(`Failed to generate playground: ${data.error}`, 'error');
      }
    }

    // Handle Docs Frame Generated
    function handleDocsFrameGenerated(data) {
      if (generateDocsFrameButton) {
        generateDocsFrameButton.disabled = false;
      }
      if (data.success) {
        updateStatus('Documentation frame generated in Figma!', 'success');
      } else {
        updateStatus(`Failed to generate docs: ${data.error}`, 'error');
      }
    }

    // Handle Batch Selection Update
    function handleBatchSelectionUpdate(data) {
      selectedComponents = data.components || [];
      if (selectedComponents.length > 1) {
        batchModeToggle.classList.remove('hidden');
      } else {
        batchModeToggle.classList.add('hidden');
        batchMode = false;
        batchModeSwitch.checked = false;
      }
    }

    // Handle Analysis Error
    function handleAnalysisError(error) {
      analyzeButton.disabled = false;
      quickAnalyzeButton.disabled = false;
      updateStatus(`Error: ${error}`, 'error');
      analysisResults.classList.add('hidden');
    }



    // Handle Fix Accessibility Button Click
    window.handleFixAccessibility = function(issue) {
      sendMessageToPlugin('fix-accessibility', {
        issue: issue,
        metadata: currentMetadata
      });
      updateStatus(`Fixing ${issue}...`, 'info');
    }

        // Helper function to extract clean suggestion name for display
    function getCleanSuggestionName(suggestion) {
      let actualName = suggestion;

      // Handle "renamed to X" format
      if (suggestion.includes('renamed to ')) {
        actualName = suggestion.split('renamed to ')[1].trim();
      }
      // Handle "should be X" format
      else if (suggestion.includes('should be ')) {
        actualName = suggestion.split('should be ')[1].trim();
      }
      // Handle " X" format
      else if (suggestion.startsWith(' ')) {
        actualName = suggestion.substring(2).trim();
      }

      // Remove any quotes that might be around the name
      return actualName.replace(/['"]/g, '').trim();
    }

    // Handle Fix Naming Button Click
    window.handleFixNaming = function(layerName, suggestion) {
      // Parse the actual suggested name from various formats
      const actualName = getCleanSuggestionName(suggestion);

      sendMessageToPlugin('fix-naming', {
        layer: layerName,
        newName: actualName,
        metadata: currentMetadata
      });
      updateStatus(`Renaming ${layerName} to ${actualName}...`, 'info');
    }

    // Update Analyze Button State
    function updateAnalyzeButtonState(enabled) {
      analyzeButton.disabled = !enabled;
      quickAnalyzeButton.disabled = !enabled;
    }

    // Update Status Message
    function updateStatus(message, type = 'info') {
      statusContainer.classList.remove('hidden');
      statusText.textContent = message;
      statusIcon.innerHTML = statusIcons[type] || statusIcons.info;

      statusDiv.classList.remove('status-info', 'status-success', 'status-error', 'status-warning');
      statusDiv.classList.add(`status-${type}`);

      if (type === 'success') {
        setTimeout(() => {
          statusContainer.classList.add('hidden');
        }, 5000);
      }
    }

    // Send Message to Plugin
    function sendMessageToPlugin(type, data) {
      console.log('Sending message to plugin:', type, data);
      try {
        parent.postMessage({
          pluginMessage: { type, data }
        }, '*');
      } catch (error) {
        console.error('Failed to send message to plugin:', error);
      }
    }

    // Select a specific node in Figma
    function selectFigmaNode(nodeId) {
      console.log('[ACTION]Selecting Figma node:', nodeId);
      sendMessageToPlugin('select-node', { nodeId });
      updateStatus('Selecting node in Figma...', 'info');
    }

    // ==================== CHAT FUNCTIONALITY ====================

    // Chat Event Handlers
    function handleSendChat() {
      if (isWaitingForResponse) return;

      const message = chatInput.value.trim();
      if (!message) return;

      // Check API key
      if (!apiKeySaved) {
        updateStatus('Please save your Claude API key first', 'error');
        return;
      }

      // Add user message to chat
      addChatMessage('user', message);

      // Clear input and disable
      chatInput.value = '';
      chatInput.disabled = true;
      sendChatButton.disabled = true;
      isWaitingForResponse = true;

      // Show container and hide empty state
      chatContainer.classList.remove('hidden');
      chatEmpty.classList.add('hidden');

      // Show loading state
      showChatLoading(true);

      // Send to plugin
      sendMessageToPlugin('chat-message', {
        message: message,
        history: chatHistory
      });
    }

    function handleClearChat() {
      if (confirm('Clear chat history?')) {
        sendMessageToPlugin('chat-clear-history', {});
      }
    }

    function handleChatKeydown(event) {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        handleSendChat();
      }
    }

    function handleChatInputChange() {
      // Auto-resize textarea
      chatInput.style.height = 'auto';
      chatInput.style.height = chatInput.scrollHeight + 'px';
    }

    // Chat Message Handlers
    function handleChatResponse(response) {
      showChatLoading(false);

      if (response && response.message) {
        addChatMessage('assistant', response.message, response.sources);
      }

      // Re-enable input
      chatInput.disabled = false;
      sendChatButton.disabled = false;
      isWaitingForResponse = false;
      chatInput.focus();
    }

    function handleChatLoading(isLoading) {
      showChatLoading(isLoading);
    }

    function handleChatError(error) {
      showChatLoading(false);

      addChatMessage('assistant', `Sorry, I encountered an error: ${error}`);

      // Re-enable input
      chatInput.disabled = false;
      sendChatButton.disabled = false;
      isWaitingForResponse = false;
      chatInput.focus();
    }

    function handleChatHistoryCleared() {
      chatHistory = [];
      chatMessages.innerHTML = '';
      chatContainer.classList.add('hidden');
      chatEmpty.classList.remove('hidden');
      updateChatComponentContext();
      updateStatus('Chat history cleared', 'success');
    }

    // Handle fix preview response
    function handleFixPreview(data) {
      if (!data || data.error) {
        updateStatus(data?.error || 'Failed to generate preview', 'error');
        return;
      }

      let previewHtml = '';
      let title = 'Confirm Fix';

      if (data.type === 'token') {
        title = 'Apply Token Fix';
        previewHtml = `
          <div class="preview-box">
            <div class="preview-label">Current Value</div>
            <div class="preview-value">${escapeHtml(data.beforeValue || 'Unknown')}</div>
          </div>
          <div class="preview-arrow"></div>
          <div class="preview-box">
            <div class="preview-label">Will Apply Token</div>
            <div class="preview-value">${escapeHtml(data.afterValue || data.tokenName || 'Design Token')}</div>
          </div>
          ${data.nodeName ? `<p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px;">On: ${escapeHtml(data.nodeName)}</p>` : ''}
        `;
      } else if (data.type === 'naming') {
        title = 'Rename Layer';
        previewHtml = `
          <div class="preview-box">
            <div class="preview-label">Current Name</div>
            <div class="preview-value">${escapeHtml(data.beforeValue || 'Unknown')}</div>
          </div>
          <div class="preview-arrow"></div>
          <div class="preview-box">
            <div class="preview-label">New Name</div>
            <div class="preview-value">${escapeHtml(data.afterValue || data.suggestedName)}</div>
          </div>
        `;
      }

      showFixModal(title, previewHtml, {
        type: data.type,
        nodeId: data.nodeId,
        propertyPath: data.propertyPath,
        tokenId: data.tokenId,
        newValue: data.afterValue || data.suggestedName
      });
    }

    // Handle fix applied response
    function handleFixApplied(data) {
      if (data.success) {
        updateStatus(`Fix applied: ${data.message || 'Success'}`, 'success');
        decrementQuickActionsCount(1);

        // Handle naming fix  find by nodeId and disable the Rename button
        if (data.fixType === 'naming' && data.nodeId) {
          const btn = document.querySelector(`.audit-action-button[data-node-id="${data.nodeId}"]`);
          if (btn) {
            btn.textContent = '\u2713';
            btn.classList.add('fix-applied');
            btn.disabled = true;
            const treeItem = btn.closest('.naming-tree-item');
            if (treeItem) {
              treeItem.style.opacity = '0.4';
              treeItem.classList.add('fix-applied-success');
            }
          }
          // Decrement naming issues count in summary bar
          const namingSummary = document.querySelector('.naming-tree-summary > span');
          if (namingSummary) {
            const match = namingSummary.textContent.match(/(\d+)/);
            if (match) {
              const remaining = Math.max(0, parseInt(match[1], 10) - 1);
              namingSummary.textContent = remaining > 0
                ? `${remaining} naming issue${remaining !== 1 ? 's' : ''} found`
                : 'All naming issues fixed';
            }
          }
          // Decrement severity count badges inside summary
          const sevCounts = document.querySelectorAll('.naming-tree-summary .sev-count');
          if (sevCounts.length > 0) {
            // First sev-count is errors (most common for naming issues)
            const firstCount = sevCounts[0];
            const countMatch = firstCount.textContent.match(/(\d+)/);
            if (countMatch) {
              const remaining = Math.max(0, parseInt(countMatch[1], 10) - 1);
              if (remaining > 0) {
                firstCount.textContent = firstCount.textContent.replace(/\d+/, remaining.toString());
              } else {
                firstCount.remove();
              }
            }
          }
        }

        // Handle token fix  find the Fix button by nodeId and disable it
        if (data.fixType === 'token' && data.nodeId) {
          // Find fix-btn inside token-item-compact that matches this nodeId
          const fixBtns = document.querySelectorAll(`.fix-btn[data-node-id="${data.nodeId}"]`);
          fixBtns.forEach(btn => {
            btn.textContent = '\u2713';
            btn.classList.add('fix-applied');
            btn.disabled = true;
            const tokenItem = btn.closest('.token-item-compact');
            if (tokenItem) {
              tokenItem.style.opacity = '0.4';
              tokenItem.classList.add('fix-applied-success');
              const nameEl = tokenItem.querySelector('.token-name');
              if (nameEl) {
                nameEl.style.textDecoration = 'line-through';
              }
            }
          });

          // Update the batch token fix bar count
          const batchBar = document.querySelector('.batch-action-bar .batch-label');
          if (batchBar) {
            const match = batchBar.textContent.match(/(\d+)/);
            if (match) {
              const remaining = Math.max(0, parseInt(match[1], 10) - 1);
              if (remaining > 0) {
                batchBar.innerHTML = `${ICO.warnTriangle} ${remaining} hard-coded value${remaining !== 1 ? 's' : ''} found`;
              } else {
                const bar = batchBar.closest('.batch-action-bar');
                if (bar) {
                  bar.innerHTML = '<span class="batch-label" style="color: var(--success);">\u2713 All hard-coded values fixed</span>';
                }
              }
            }
          }
        }

      } else {
        updateStatus(`Failed to apply fix: ${data.error || 'Unknown error'}`, 'error');
      }
    }

    // Update the fix summary bar with remaining fixable count
    function updateFixSummaryCount() {
      const bar = document.getElementById('fix-summary-bar');
      if (!bar) return;

      const countEl = bar.querySelector('strong');
      if (countEl && quickActionsFixCount > 0) {
        countEl.textContent = `${quickActionsFixCount} fixable issue${quickActionsFixCount !== 1 ? 's' : ''}`;
      }

      // Show completion message when all fixed (only once)
      if (quickActionsFixCount === 0) {
        let statusMsg = bar.querySelector('.fix-status-msg');
        if (!statusMsg) {
          statusMsg = document.createElement('span');
          statusMsg.className = 'fix-status-msg';
          statusMsg.style.cssText = 'font-size:var(--font-size-xs);color:var(--success-text);font-weight:var(--font-weight-medium);white-space:nowrap;';
          statusMsg.textContent = 'All fixed \u2014 Re-analyze to verify';
          bar.appendChild(statusMsg);
        }
        // Hide the Fix All button
        const fixAllBtn = bar.querySelector('.quick-actions-btn');
        if (fixAllBtn) fixAllBtn.style.display = 'none';
      }
    }

    // Handle batch fix response
    function handleBatchFixApplied(data) {
      const successCount = data.success || data.appliedCount || 0;
      const errorCount = data.errors || data.failedCount || 0;
      const total = data.total || (successCount + errorCount);

      if (errorCount === 0) {
        updateStatus(`All ${successCount} fixes applied successfully! Re-analyze to see updated results.`, 'success');
      } else if (successCount > 0) {
        updateStatus(`Applied ${successCount}/${total} fixes (${errorCount} failed). Re-analyze to see updated results.`, 'warning');
      } else {
        updateStatus(`Failed to apply ${errorCount} fix${errorCount !== 1 ? 'es' : ''}`, 'error');
      }

      // Update quick actions count
      decrementQuickActionsCount(successCount);

      // Mark successfully renamed naming tree items
      if (data.results && data.results.length > 0) {
        let namingSuccessCount = 0;
        data.results.forEach(result => {
          if (result.success && result.nodeId) {
            const btn = document.querySelector(`.audit-action-button[data-node-id="${result.nodeId}"]`);
            if (btn) {
              btn.textContent = '\u2713';
              btn.classList.add('fix-applied');
              btn.disabled = true;
              const treeItem = btn.closest('.naming-tree-item');
              if (treeItem) {
                treeItem.style.opacity = '0.4';
                treeItem.classList.add('fix-applied-success');
              }
              namingSuccessCount++;
            }
          }
        });

        // Update naming summary count
        if (namingSuccessCount > 0) {
          const namingSummary = document.querySelector('.naming-tree-summary > span');
          if (namingSummary) {
            const match = namingSummary.textContent.match(/(\d+)/);
            if (match) {
              const remaining = Math.max(0, parseInt(match[1], 10) - namingSuccessCount);
              namingSummary.textContent = remaining > 0
                ? `${remaining} naming issue${remaining !== 1 ? 's' : ''} found`
                : 'All naming issues fixed';
            }
          }
          // Hide severity badges and Rename All button when all done
          const renameAllBtn = document.getElementById('rename-all-btn');
          const namingSummaryEl = document.querySelector('.naming-tree-summary > span');
          if (namingSummaryEl && namingSummaryEl.textContent === 'All naming issues fixed') {
            const sevCounts = document.querySelector('.naming-tree-summary .severity-counts');
            if (sevCounts) sevCounts.style.display = 'none';
            if (renameAllBtn) {
              renameAllBtn.textContent = '\u2713 Done';
              renameAllBtn.disabled = true;
              renameAllBtn.classList.add('fix-applied');
            }
          }
        }
      }

      // Disable the Fix All button in the fix-summary-bar (not the Rename All button)
      const fixAllBtn = document.querySelector('#fix-summary-bar .quick-actions-btn');
      if (fixAllBtn && successCount > 0) {
        fixAllBtn.textContent = '\u2713 Applied';
        fixAllBtn.disabled = true;
        fixAllBtn.classList.add('fix-applied');
      }
    }

    // =============================================
    // Auto-Fix UI Functions (Phases 2-8)
    // =============================================

    // Phase 2: Compute fixable issue counts from analysis data
    // Only naming issues are truly auto-fixable. Token hard-coded values and
    // accessibility failures require manual intervention.
    function computeFixableCounts(data) {
      const counts = { tokens: 0, naming: 0, accessibility: 0, total: 0 };

      // Count naming issues (auto-fixable via rename)
      if (data.namingIssues && data.namingIssues.length > 0) {
        counts.naming = data.namingIssues.length;
      }

      counts.total = counts.naming;
      return counts;
    }

    // Phase 2: Render Quick Actions bar at top of analysis results
    function renderQuickActionsBar(counts) {
      if (counts.total === 0) return '';

      quickActionsFixCount = counts.total;

      return `
        <div class="fix-summary-bar" id="fix-summary-bar">
          <div class="fix-summary-stats">
            <strong>${counts.total} fixable issue${counts.total !== 1 ? 's' : ''}</strong>
            <span class="stat-chip">${counts.naming} naming</span>
          </div>
          <button class="quick-actions-btn" onclick="handleRenameAll()">Rename All</button>
        </div>
      `;
    }

    // Handle "Rename All" from Quick Actions bar and naming tree summary
    function handleRenameAll() {
      if (!currentNamingIssues || currentNamingIssues.length === 0) {
        updateStatus('No naming issues to fix', 'info');
        return;
      }

      // Only collect issues that haven't been fixed yet
      const unfixedIssues = currentNamingIssues.filter(issue => {
        const btn = document.querySelector(`.audit-action-button[data-node-id="${issue.nodeId}"]`);
        return !btn || !btn.disabled;
      });

      if (unfixedIssues.length === 0) {
        updateStatus('All naming issues already fixed', 'info');
        return;
      }

      const fixes = unfixedIssues.map(issue => ({
        type: 'naming',
        nodeId: issue.nodeId,
        newValue: issue.suggestedName
      }));

      const previewHtml = `
        <div style="margin-bottom: 12px;">
          <p style="font-size: 12px; margin-bottom: 8px;">This will rename <strong>${fixes.length}</strong> layer${fixes.length !== 1 ? 's' : ''} to semantic names.</p>
          <div style="max-height: 200px; overflow-y: auto; font-size: 11px; color: var(--text-secondary);">
            ${unfixedIssues.map(issue => `<div style="margin-bottom: 4px; padding: 2px 0;"><span style="opacity: 0.6;">${escapeHtml(issue.currentName)}</span>  <strong>${escapeHtml(issue.suggestedName)}</strong></div>`).join('')}
          </div>
        </div>
      `;

      showFixModal('Rename All Layers', previewHtml, {
        type: 'batch',
        fixes: fixes
      });
    }

    // Handle update description
    function handleUpdateDescription() {
      if (!lastAnalyzedNodeId || !currentMetadata) {
        updateStatus('No component analyzed yet', 'info');
        return;
      }

      const currentDesc = currentMetadata.description || '';

      const previewHtml = `
        <div style="margin-bottom: 12px;">
          <label style="font-size: 11px; font-weight: 500; display: block; margin-bottom: 4px;">Component Description:</label>
          <textarea id="description-textarea" style="
            width: 100%;
            min-height: 80px;
            padding: 8px;
            font-size: 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            resize: vertical;
            font-family: inherit;
            box-sizing: border-box;
          ">${escapeHtml(currentDesc)}</textarea>
          <p style="font-size: 10px; color: var(--text-tertiary); margin-top: 4px;">This will update the component description in Figma.</p>
        </div>
      `;

      showFixModal('Update Component Description', previewHtml, {
        type: 'description',
        nodeId: lastAnalyzedNodeId,
        description: currentDesc
      });
    }

    // Store recommendations globally for copy access
    let _currentRecommendations = [];

    // Phase 6: Copy property recommendation by index
    function copyRecommendationByIndex(index) {
      const rec = _currentRecommendations[index];
      if (!rec) {
        updateStatus('Recommendation not found', 'error');
        return;
      }
      const text = `${rec.name} (${rec.type}): ${(rec.examples || []).join(', ')}`;
      copyToClipboard(text, `[data-rec-index="${index}"]`);
    }

    // Clipboard helper with fallback for Figma plugin iframe
    function copyToClipboard(text, btnSelector) {
      const showSuccess = () => {
        const btn = document.querySelector(`.copy-btn${btnSelector || ''}`);
        if (btn) {
          btn.classList.add('copied');
          const origHTML = btn.innerHTML;
          btn.innerHTML = '<svg width="12" height="12" viewBox="0 0 16 16" fill="currentColor"><path d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"/></svg>';
          setTimeout(() => {
            btn.classList.remove('copied');
            btn.innerHTML = origHTML;
          }, 2000);
        }
        updateStatus('Copied to clipboard', 'success');
      };

      // Try modern API first, fall back to execCommand
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).then(showSuccess).catch(() => {
          fallbackCopy(text, showSuccess);
        });
      } else {
        fallbackCopy(text, showSuccess);
      }
    }

    function fallbackCopy(text, onSuccess) {
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.style.cssText = 'position:fixed;left:-9999px;top:-9999px';
      document.body.appendChild(ta);
      ta.select();
      try {
        document.execCommand('copy');
        if (onSuccess) onSuccess();
      } catch (e) {
        updateStatus('Failed to copy to clipboard', 'error');
      }
      document.body.removeChild(ta);
    }

    // Phase 8: Handle description updated response
    function handleDescriptionUpdated(data) {
      if (data.success) {
        updateStatus('Component description updated!', 'success');
        // Update local metadata
        if (currentMetadata) {
          currentMetadata.description = data.newDescription;
        }
      } else {
        updateStatus(`Failed to update description: ${data.error || 'Unknown error'}`, 'error');
      }
    }


    // Phase 8: Update quick actions count after fix
    function decrementQuickActionsCount(amount) {
      quickActionsFixCount = Math.max(0, quickActionsFixCount - (amount || 1));
      updateFixSummaryCount();
    }

    // Chat UI Functions
    function addChatMessage(role, content, sources = null) {
      const messageId = 'msg-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);

      const message = {
        id: messageId,
        role: role,
        content: content,
        timestamp: Date.now(),
        sources: sources
      };

      chatHistory.push(message);

      const messageDiv = document.createElement('div');
      messageDiv.className = `chat-message ${role}`;
      messageDiv.dataset.messageId = messageId;

      let messageHTML = `
        <div class="chat-message-content">${formatChatContent(content)}</div>
        <div class="chat-message-meta">
          <span>${formatTimestamp(message.timestamp)}</span>
        </div>
      `;

      // Add sources if available
      if (sources && sources.length > 0) {
        // Filter out empty or duplicate sources
        const validSources = sources.filter(source =>
          source &&
          source.title &&
          source.content &&
          source.title.trim() !== '' &&
          source.content.trim() !== ''
        );

        // Remove duplicates based on title
        const uniqueSources = validSources.filter((source, index, arr) =>
          arr.findIndex(s => s.title === source.title) === index
        );

        if (uniqueSources.length > 0) {
          messageHTML += `
            <div class="chat-sources">
              <div class="chat-sources-title">
                Sources
              </div>
              ${uniqueSources.map(source => `
                <div class="chat-source">
                  <div class="chat-source-title">${source.title}</div>
                  <div class="chat-source-content">${source.content.substring(0, 150)}${source.content.length > 150 ? '...' : ''}</div>
                </div>
              `).join('')}
            </div>
          `;
        }
      }

      messageDiv.innerHTML = messageHTML;
      chatMessages.appendChild(messageDiv);

      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function showChatLoading(isLoading) {
      // Always remove existing loading indicator first
      const existingLoading = document.getElementById('chat-loading');
      if (existingLoading) {
        existingLoading.remove();
      }

      if (isLoading) {
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'chat-message assistant';
        loadingDiv.id = 'chat-loading';
        loadingDiv.innerHTML = `
          <div class="chat-message-content">
            <div class="loading-dots">
              <span></span>
              <span></span>
              <span></span>
            </div>
          </div>
        `;
        chatMessages.appendChild(loadingDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }
    }

    function formatChatContent(content) {
      // Simple markdown-to-HTML converter that handles common patterns correctly
      
      // Convert markdown to HTML using a simple state machine
      const lines = content.split('\n');
      const htmlLines = [];
      let currentBlock = null;
      let currentBlockContent = [];
      
      const closeCurrentBlock = () => {
        if (currentBlock === 'paragraph' && currentBlockContent.length > 0) {
          htmlLines.push(`<p>${currentBlockContent.join(' ')}</p>`);
        } else if (currentBlock === 'ol') {
          htmlLines.push('</ol>');
        } else if (currentBlock === 'ul') {
          htmlLines.push('</ul>');
        }
        currentBlock = null;
        currentBlockContent = [];
      };
      
      // Process inline markdown (bold, italic, code)
      function processInlineMarkdown(text) {
        return text
          // Code spans (do this first to avoid conflicts)
          .replace(/`([^`]+)`/g, '<code>$1</code>')
          // Bold
          .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
          // Italic (avoid matching list markers)
          .replace(/(\s|^)\*([^*\s][^*]*)\*(\s|$)/g, '$1<em>$2</em>$3');
      }
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const trimmedLine = line.trim();
        
        // Empty line - close current block
        if (trimmedLine === '') {
          closeCurrentBlock();
          continue;
        }
        
        // Headers
        const headerMatch = line.match(/^(#{1,6})\s+(.+)$/);
        if (headerMatch) {
          closeCurrentBlock();
          const level = Math.min(headerMatch[1].length + 1, 6); // Offset by 1 for better hierarchy
          htmlLines.push(`<h${level}>${processInlineMarkdown(headerMatch[2])}</h${level}>`);
          continue;
        }
        
        // Ordered list
        const orderedMatch = line.match(/^(\s*)(\d+)\.\s+(.+)$/);
        if (orderedMatch) {
          const [, indent, num, content] = orderedMatch;
          const indentLevel = indent.length;
          
          // Check if we need to start a new list
          if (currentBlock !== 'ol') {
            closeCurrentBlock();
            htmlLines.push('<ol>');
            currentBlock = 'ol';
          }
          
          // Add list item - check for nested content
          let itemHtml = `<li>${processInlineMarkdown(content)}`;
          
          // Look ahead for nested lists
          let j = i + 1;
          const nestedItems = [];
          while (j < lines.length && lines[j].match(/^\s+[-*]\s+/)) {
            const nestedMatch = lines[j].match(/^\s*[-*]\s+(.+)$/);
            if (nestedMatch) {
              nestedItems.push(nestedMatch[1]);
            }
            j++;
          }
          
          if (nestedItems.length > 0) {
            itemHtml += '\n<ul>';
            nestedItems.forEach(item => {
              itemHtml += `\n<li>${processInlineMarkdown(item)}</li>`;
            });
            itemHtml += '\n</ul>';
            i = j - 1; // Skip the nested items we just processed
          }
          
          itemHtml += '</li>';
          htmlLines.push(itemHtml);
          continue;
        }
        
        // Unordered list
        const unorderedMatch = line.match(/^(\s*)[-*]\s+(.+)$/);
        if (unorderedMatch) {
          const [, indent, content] = unorderedMatch;
          
          // Check if we're at root level (not nested)
          if (indent.length === 0) {
            if (currentBlock !== 'ul') {
              closeCurrentBlock();
              htmlLines.push('<ul>');
              currentBlock = 'ul';
            }
            htmlLines.push(`<li>${processInlineMarkdown(content)}</li>`);
            continue;
          }
        }
        
        // Regular paragraph text
        if (currentBlock !== 'paragraph') {
          closeCurrentBlock();
          currentBlock = 'paragraph';
        }
        currentBlockContent.push(processInlineMarkdown(trimmedLine));
      }
      
      // Close any remaining block
      closeCurrentBlock();
      
      return '<div class="chat-article">' + htmlLines.join('\n') + '</div>';
    }

    function formatTimestamp(timestamp) {
      const date = new Date(timestamp);
      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    // Update chat input state based on API key
    function updateChatInputState() {
      if (chatInput && sendChatButton) {
        chatInput.disabled = !apiKeySaved;
        sendChatButton.disabled = !apiKeySaved;

        if (apiKeySaved) {
          chatInput.placeholder = "Ask about design systems, components, tokens, or best practices...";
        } else {
          chatInput.placeholder = "Save your Claude API key first to start chatting...";
        }
      }
    }

    // Update chat component context display
    function updateChatComponentContext() {
      const contextIndicator = document.getElementById('component-context-indicator');
      const componentInfo = document.getElementById('current-component-info');
      const chatSuggestions = document.getElementById('chat-suggestions');

      if (!contextIndicator || !componentInfo || !chatSuggestions) return;

      // Check if we have current component metadata
      const hasComponent = currentMetadata !== null;

      if (hasComponent && currentMetadata) {
        // Show component context
        contextIndicator.classList.remove('hidden');
        componentInfo.innerHTML = `Currently analyzing: <strong>${currentMetadata.component}</strong>`;

        // Update suggestions for component-specific questions
        chatSuggestions.innerHTML = `
          <button class="chat-suggestion" onclick="sendChatSuggestion('What issues does this component have?')">Issues</button>
          <button class="chat-suggestion" onclick="sendChatSuggestion('How can I improve this component?')">Improvements</button>
          <button class="chat-suggestion" onclick="sendChatSuggestion('What design tokens should I use?')">Tokens</button>
          <button class="chat-suggestion" onclick="sendChatSuggestion('Is this component accessible?')">Accessibility</button>
        `;
      } else {
        // Hide component context and show general suggestions
        contextIndicator.classList.add('hidden');
        chatSuggestions.innerHTML = `
          <button class="chat-suggestion" onclick="sendChatSuggestion('What are design system best practices?')">Best Practices</button>
          <button class="chat-suggestion" onclick="sendChatSuggestion('How do I organize design tokens?')">Tokens</button>
          <button class="chat-suggestion" onclick="sendChatSuggestion('What makes a good component API?')">Components</button>
          <button class="chat-suggestion" onclick="sendChatSuggestion('How do I ensure accessibility?')">Accessibility</button>
        `;
      }
    }

    // Send chat suggestion
    window.sendChatSuggestion = function(suggestion) {
      if (chatInput) {
        chatInput.value = suggestion;
        handleSendChat();
      }
    };

    // Initialize when DOM is loaded
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeUI);
    } else {
      initializeUI();
    }
  </script>
</body>
</html>
